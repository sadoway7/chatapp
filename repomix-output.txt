This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.dockerignore
.gitignore
Dockerfile
index.html
model-loading-indicator-plan.md
package.json
public/config.json
public/icon.svg
README.md
src/api/openwebui.js
src/App.jsx
src/commands.js
src/components/ChatInput.jsx
src/components/ChatMessages.jsx
src/components/FileUpload.jsx
src/components/Header.jsx
src/components/SettingsModal.jsx
src/FILE_MAP.md
src/index.css
src/main.jsx
src/utils/config.js
src/utils/error.js
src/utils/message.js
src/utils/message.jsx
vite.config.js

================================================================
Files
================================================================

================
File: .dockerignore
================
node_modules
npm-debug.log
.git
.gitignore

================
File: .gitignore
================
/node_modules
package-lock.json

================
File: Dockerfile
================
# Use Node.js 18 as base
FROM node:18-slim

# Set working directory
WORKDIR /app

# Copy package files first (for better caching)
COPY package*.json ./

# Install dependencies and Vite explicitly
RUN npm install && npm install vite@latest

# Copy the rest of the app
COPY . .

# Build the app
RUN npm run build

# Expose the port (make sure this matches your vite.config.js)
EXPOSE 4173

# Start the application in preview mode
CMD ["npm", "run", "preview", "--", "--host", "0.0.0.0"]

================
File: index.html
================
<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <title>chat.sadoway</title>
      </head>
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.jsx"></script>
      </body>
    </html>

================
File: model-loading-indicator-plan.md
================
# Model Loading Indicator Implementation Plan

## Overview

The goal is to add a visual indicator in the header that shows when a model is being loaded after switching models. Since the OpenWebUI API doesn't provide a direct way to check if a model is loaded or loading, we'll implement a solution that simulates this behavior.

## Implementation Steps

### 1. Add Model Loading State to App.jsx

```jsx
// Add a new state variable
const [isModelLoading, setIsModelLoading] = useState(false);
const [loadingModel, setLoadingModel] = useState('');
```

### 2. Update the Header Component

Modify the Header component to accept and display the model loading status:

```jsx
// Header.jsx
const Header = ({ handleClearChat, isModelLoading, loadingModel }) => {
  return (
    <div className="chat-header">
      <div className="logo-container">
        {/* Existing logo SVG */}
        <h2 className="logo-text">chat<span className="logo-dot">.</span>sadoway</h2>
      </div>
      
      {/* Add model loading indicator */}
      {isModelLoading && (
        <div className="model-loading-indicator">
          <div className="loading-spinner"></div>
          <span>Loading {loadingModel}...</span>
        </div>
      )}
      
      <div className="header-buttons">
        <button className="clear-button" onClick={handleClearChat}>
          Clear
        </button>
      </div>
    </div>
  );
};
```

### 3. Update Model Selection Logic in ChatInput.jsx

Modify the `selectModel` function to trigger the loading state:

```jsx
// ChatInput.jsx
const selectModel = (model) => {
  // Set the selected model
  setSelectedModel(model);
  
  // Trigger loading state in parent component
  onModelChange(model);
  
  // Close the dropdown
  setDropdownOpen(false);
};
```

Update the component props to include the new callback:

```jsx
const ChatInput = ({
  // Existing props
  onModelChange,
  // Other props
}) => {
  // Component implementation
};
```

### 4. Update App.jsx to Handle Model Changes

Add a handler function for model changes:

```jsx
const handleModelChange = (modelId) => {
  // Set loading state
  setIsModelLoading(true);
  setLoadingModel(modelId);
  
  // Store the model ID in localStorage
  localStorage.setItem('selectedModel', modelId);
  
  // Simulate loading time (3-5 seconds)
  setTimeout(() => {
    setIsModelLoading(false);
    setLoadingModel('');
  }, 3000 + Math.random() * 2000); // Random time between 3-5 seconds
};
```

Update the ChatInput component call:

```jsx
<ChatInput
  // Existing props
  onModelChange={handleModelChange}
  // Other props
/>
```

Update the Header component call:

```jsx
<Header 
  handleClearChat={handleClearChat} 
  isModelLoading={isModelLoading}
  loadingModel={loadingModel}
/>
```

### 5. Add CSS Styles for the Loading Indicator

Add the following CSS to index.css:

```css
/* Model loading indicator */
.model-loading-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  background-color: rgba(255, 152, 0, 0.15);
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 0.9rem;
  color: #f0f0f0;
  margin-right: 12px;
}

.loading-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid #ff9800;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
```

## Additional Considerations

1. **Error Handling**: If the model fails to load, we should display an error message.
2. **Disable Input**: Consider disabling the chat input while a model is loading.
3. **Persistence**: The loading state should be reset if the page is refreshed.
4. **API Integration**: If the OpenWebUI API adds support for checking model loading status in the future, update the implementation to use the actual API.

## Testing

1. Test switching between different models
2. Test the loading indicator appearance and disappearance
3. Test the behavior when switching models rapidly
4. Test the behavior when sending messages while a model is loading

## Future Improvements

1. Add a progress bar or more detailed loading information if the API provides it
2. Add model-specific information in the header (e.g., parameter count, quantization)
3. Allow canceling a model load operation

================
File: package.json
================
{
  "name": "chat-sadoway",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "marked": "^15.0.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^4.12.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.28",
    "@types/react-dom": "^18.0.11",
    "@vitejs/plugin-react": "^3.1.0",
    "vite": "^4.5.2"
  }
}

================
File: public/config.json
================
{
    "openWebUIUrl": "https://open.sadoway.ca",
    "apiKey": "sk-e0519f98601c409e8336dbc292bc6c42",
    "selectedModel": "phi4-mini:latest"
}

================
File: public/icon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <!-- Background -->
  <rect width="512" height="512" rx="100" fill="#1a1a1a"/>
  
  <!-- Stylized "L2" -->
  <path d="M 120 140
           L 120 340
           L 220 340"
        stroke="#4f46e5"
        stroke-width="40"
        stroke-linecap="round"
        stroke-linejoin="round"
        fill="none"/>
  
  <!-- Chat/AI element -->
  <path d="M 280 180
           Q 420 180 420 260
           Q 420 340 280 340
           L 260 340
           L 240 380
           L 220 340"
        stroke="#4f46e5"
        stroke-width="40"
        stroke-linecap="round"
        stroke-linejoin="round"
        fill="none"/>
  
  <!-- Decorative dots -->
  <circle cx="300" cy="260" r="12" fill="#4f46e5"/>
  <circle cx="350" cy="260" r="12" fill="#4f46e5"/>
  <circle cx="400" cy="260" r="12" fill="#4f46e5"/>
</svg>

================
File: README.md
================
# chat.sadoway

A web-based interface for interacting with Ollama models, designed to run on Unraid.

## Prerequisites
- Unraid server
- Docker installed on Unraid
- Git access

## Installation Steps

1. **Navigate to appdata Directory**
   ```bash
   cd /mnt/user/appdata
   ```

2. **Clone the Repository**
   ```bash
   git clone https://github.com/sadoway7/chat-sadoway.git
   ```

3. **Configure Domain Access**
   ```bash
   cd chat-sadoway
   nano vite.config.js
   ```
   
   Replace the entire content of the file with:
   ```javascript
   import { defineConfig } from 'vite'
   import react from '@vitejs/plugin-react'

   export default defineConfig({
     plugins: [react()],
     preview: {
       host: '0.0.0.0',
       port: 4173,
       strictPort: true,
       allowedHosts: ['your.domain.com']  // Replace with your domain
     },
     server: {
       host: '0.0.0.0',
       port: 4173,
       strictPort: true,
       allowedHosts: ['your.domain.com']  // Replace with your domain
     }
   })
   ```
   
   Save the file:
   - Press `CTRL + X` to exit
   - Press `Y` to save changes
   - Press `ENTER` to confirm

4. **Configure Docker Container**
   - Open Unraid's Docker tab
   - Click "Add Container"
   - Configure the following settings:

   **Basic Configuration:**
   - Name: `chat-sadoway`
   - Repository: `node:20-slim`
   - Network Type: `Bridge`
   - Console: `Shell`

   **Post Arguments:**
   ```bash
   sh -c "cd /app && rm -rf node_modules package-lock.json && NODE_ENV=development npm install && npm run build && NODE_ENV=production npm run preview -- --host 0.0.0.0"
   ```

   **Path Configuration:**
   - Config Type: `Path`
   - Name: `App Data`
   - Host Path: `/mnt/user/appdata/chat-sadoway`
   - Container Path: `/app`

   **Port Configuration:**
   - Config Type: `Port`
   - Name: `Web UI`
   - Host Port: `4127`
   - Container Port: `4127`
   - Connection Type: `TCP`

5. **Start the Container**
   - Click "Apply" to save the container settings
   - Start the container from the Docker UI

6. **Access the Application**
   - Open your browser
   - Navigate to `http://your.domain.com:4127` or `http://localhost:4127`

7. **Initial Setup**
   - Send the message `settings123!` in the chat to access the settings menu
   - Configure your Ollama URL
   - Select your preferred model (e.g., llama2, mistral)
   - Save your settings

## Notes
- Settings access via `settings123!` is temporary and will be updated in future versions
- The configuration is currently stored in browser cache and needs to be set up locally on first use
- Server-side configuration is planned for future updates
- For cleaner URLs without port numbers, consider using NGINX for domain mapping

## Contributing
This is a hobby project I'm working on in my spare time. Feel free to open issues or submit pull requests, but please note that response times may vary as this is a side project.

## License
Released under MIT License. Feel free to use, modify, and share this project.

## Support
This is a hobby project maintained in my free time. If you find bugs or have questions, feel free to open an issue on GitHub. I'll help when I can, but responses might take some time.

================
File: src/api/openwebui.js
================
import { handleApiError } from '../utils/error';

export const uploadFile = async (openWebUIUrl, apiKey, file) => {
  console.log('API: uploadFile called with file:', file.name, file.type, file.size);
  console.log('API: Using URL:', `${openWebUIUrl}/api/v1/files/`);
  
  const headers = {};
  if (apiKey) {
    // Ensure the API key is properly formatted with 'Bearer ' prefix
    headers['Authorization'] = apiKey.startsWith('Bearer ') ? apiKey : `Bearer ${apiKey}`;
    console.log('API: Using API key starting with:', apiKey.substring(0, 15) + '...');
  } else {
    console.warn('API: No API key provided for file upload');
  }

  try {
    console.log('API: Creating FormData and appending file');
    const formData = new FormData();
    formData.append('file', file);

    console.log('API: Sending fetch request');
    const response = await fetch(`${openWebUIUrl}/api/v1/files/`, {
      method: 'POST',
      headers,
      body: formData,
    });

    console.log('API: Received response with status:', response.status);
    if (!response.ok) {
      const errorText = await response.text();
      console.error('API: Error response body:', errorText);
      throw new Error(`Failed to upload file: ${response.status} ${response.statusText}\n${errorText}`);
    }

    const data = await response.json();
    console.log('API: Successfully parsed response:', data);
    return data;
  } catch (error) {
    console.error('API: Error in uploadFile:', error);
    handleApiError(error, 'uploadFile');
    throw error;
  }
};

export const fetchModels = async (openWebUIUrl, apiKey) => {
  const headers = {
    'Content-Type': 'application/json',
  };
  if (apiKey) {
    // Ensure the API key is properly formatted with 'Bearer ' prefix
    headers['Authorization'] = apiKey.startsWith('Bearer ') ? apiKey : `Bearer ${apiKey}`;
    console.log('API: Using API key starting with:', apiKey.substring(0, 15) + '...');
  } else {
    console.warn('API: No API key provided');
  }

  try {
    console.log('Fetching models from:', `${openWebUIUrl}/api/models`);
    const response = await fetch(`${openWebUIUrl}/api/models`, { headers });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to fetch models: ${response.status} ${response.statusText}\n${errorText}`);
    }
    const data = await response.json();
    console.log('Raw models response:', data);
    
    // Handle different response formats from the API
    let modelsList = [];
    
    if (data && Array.isArray(data)) {
      // Direct array format
      modelsList = data;
      console.log('Direct array format detected');
    } else if (data && Array.isArray(data.data)) {
      // Object with data array format
      modelsList = data.data;
      console.log('Object with data array format detected');
    } else if (data && typeof data === 'object') {
      // Object with model properties format
      // Convert object keys to array of model IDs
      modelsList = Object.keys(data).map(key => ({
        id: key,
        name: key
      }));
      console.log('Object with model properties format detected');
    } else {
      console.error('Unrecognized model response format:', data);
      throw new Error('Invalid response format from OpenWebUI API.');
    }
    
    // Log the parsed models data for debugging
    console.log('Parsed models data:', modelsList);
    return modelsList;
  } catch (error) {
    console.error('Error in fetchModels:', error);
    handleApiError(error, 'fetchModels');
    throw error;
  }
};

export const sendChatMessage = async (openWebUIUrl, apiKey, model, messages, fileId = null) => {
  // Ensure model is a string (model ID)
  const modelId = typeof model === 'object' ? model.id : model;
  console.log('API: sendChatMessage called with model:', modelId);
  console.log('API: Messages count:', messages.length);
  console.log('API: File ID:', fileId);
  
  const headers = {
    'Content-Type': 'application/json',
  };
  if (apiKey) {
    // Ensure the API key is properly formatted with 'Bearer ' prefix
    headers['Authorization'] = apiKey.startsWith('Bearer ') ? apiKey : `Bearer ${apiKey}`;
    console.log('API: Using API key starting with:', apiKey.substring(0, 15) + '...');
  } else {
    console.warn('API: No API key provided for chat message');
  }

  try {
    // Format messages to ensure they follow the correct structure
    // Extract only the role and content from each message
    const formattedMessages = messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    
    const payload = {
      model: modelId,
      messages: formattedMessages,
      stream: false
    };

    // Add file reference if provided
    if (fileId) {
      console.log('API: Adding file reference to payload:', fileId);
      payload.files = [
        { type: 'file', id: fileId }
      ];
    }

    console.log('API: Sending chat completion request');
    const response = await fetch(`${openWebUIUrl}/api/chat/completions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    });

    console.log('API: Received response with status:', response.status);
    if (!response.ok) {
      const errorText = await response.text();
      console.error('API: Error response body:', errorText);
      throw new Error(`Failed to send message: ${response.status} ${response.statusText}\n${errorText}`);
    }

    const data = await response.json();
    console.log('API: Successfully parsed response:', data);
    
    // Extract the assistant message content
    let content = '';
    if (data.choices && data.choices[0] && data.choices[0].message) {
      content = data.choices[0].message.content;
      console.log('API: Extracted content from choices array');
    } else if (data.content) {
      content = data.content;
      console.log('API: Extracted content directly from response');
    } else {
      console.warn('API: Could not extract content from response:', data);
      // Return the entire data object as fallback
    }
    
    return data;
  } catch (error) {
    console.error('API: Error in sendChatMessage:', error);
    handleApiError(error, 'sendChatMessage');
    throw error;
  }
};
/**
 * Send a chat message with streaming response
 * @param {string} openWebUIUrl - The URL of the OpenWebUI API
 * @param {string} apiKey - The API key for authentication
 * @param {string} model - The model to use for the chat
 * @param {Array} messages - The messages to send
 * @param {string|null} fileId - The ID of the file to include in the message
 * @param {Function} onChunk - Callback function to handle each chunk of the response
 * @param {Function} onComplete - Callback function to handle the complete response
 * @returns {AbortController} - Controller that can be used to abort the stream
 */
export const sendChatMessageStreaming = async (openWebUIUrl, apiKey, model, messages, fileId = null, onChunk, onComplete) => {
  // Create an AbortController to allow canceling the stream
  const controller = new AbortController();
  const signal = controller.signal;
  // Ensure model is a string (model ID)
  const modelId = typeof model === 'object' ? model.id : model;
  console.log('API: sendChatMessageStreaming called with model:', modelId);
  console.log('API: Messages count:', messages.length);
  console.log('API: File ID:', fileId);
  
  const headers = {
    'Content-Type': 'application/json',
  };
  if (apiKey) {
    // Ensure the API key is properly formatted with 'Bearer ' prefix
    headers['Authorization'] = apiKey.startsWith('Bearer ') ? apiKey : `Bearer ${apiKey}`;
    console.log('API: Using API key starting with:', apiKey.substring(0, 15) + '...');
  } else {
    console.warn('API: No API key provided for streaming chat message');
  }

  try {
    // Format messages to extract only role and content, removing any additional metadata
    const formattedMessages = messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    
    const payload = {
      model: modelId,
      messages: formattedMessages,
      stream: true // Enable streaming
    };
    
    console.log('API: Streaming request payload:', JSON.stringify(payload));

    // Add file reference if provided
    if (fileId) {
      console.log('API: Adding file reference to payload:', fileId);
      payload.files = [
        { type: 'file', id: fileId }
      ];
    }

    console.log('API: Sending streaming chat completion request');
    const response = await fetch(`${openWebUIUrl}/api/chat/completions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
      signal // Add the abort signal
    });

    console.log('API: Received response with status:', response.status);
    if (!response.ok) {
      const errorText = await response.text();
      console.error('API: Error response body:', errorText);
      throw new Error(`Failed to send message: ${response.status} ${response.statusText}\n${errorText}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullContent = '';
    
    console.log('API: Starting to read streaming response');
    try {
      while (true) {
        // Check if the request has been aborted before reading
        if (signal.aborted) {
          console.log('API: Stream was aborted by user before read');
          // Call onComplete with the content so far
          onComplete(fullContent + " [Generation stopped]");
          return controller;
        }
        
        const { done, value } = await reader.read();
        if (done) {
          console.log('API: Streaming response complete');
          break;
        }
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            if (data === '[DONE]') continue;
            
            try {
              const parsed = JSON.parse(data);
              let content = null;
              
              // Handle different streaming response formats
              if (parsed.choices && parsed.choices[0].delta && parsed.choices[0].delta.content) {
                // OpenAI-compatible format
                content = parsed.choices[0].delta.content;
                console.log('API: Parsed OpenAI-compatible delta content');
              } else if (parsed.choices && parsed.choices[0].message && parsed.choices[0].message.content) {
                // Some APIs might send complete message chunks
                content = parsed.choices[0].message.content;
                console.log('API: Parsed complete message content chunk');
              } else if (parsed.content) {
                // Simpler format with direct content
                content = parsed.content;
                console.log('API: Parsed direct content');
              } else if (parsed.text) {
                // Another common format
                content = parsed.text;
                console.log('API: Parsed text content');
              }
              
              if (content) {
                fullContent += content;
                onChunk(content);
              } else {
                console.log('API: No content found in streaming response chunk:', parsed);
              }
            } catch (e) {
              console.error('API: Error parsing streaming response:', e);
            }
          }
        }
      }
      
      // Call onComplete with the full content when done
      console.log('API: Streaming complete, full content length:', fullContent.length);
      onComplete(fullContent);
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('API: Stream was aborted by user');
        // Call onComplete with the content so far plus a message
        onComplete(fullContent + " [Generation stopped]");
      } else {
        throw error;
      }
    }
  } catch (error) {
    console.error('API: Error in sendChatMessageStreaming:', error);
    handleApiError(error, 'sendChatMessageStreaming');
    throw error;
  }
  
  // Return the controller so it can be used to abort the stream
  return controller;
};

================
File: src/App.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { FiSquare } from 'react-icons/fi';
import Header from './components/Header';
import ChatInput from './components/ChatInput';
import ChatMessages from './components/ChatMessages';
import SettingsModal from './components/SettingsModal';
import { fetchModels, sendChatMessage, sendChatMessageStreaming, uploadFile } from './api/openwebui';
import { handleCommand } from './commands';
import { handleApiError } from './utils/error';
import { loadConfig } from './utils/config';
import './index.css';

function App() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [openWebUIUrl, setOpenWebUIUrl] = useState('');
  const [apiKey, setApiKey] = useState('');
  const [models, setModels] = useState([]);
  const [selectedModel, setSelectedModel] = useState('');
  const [fetchError, setFetchError] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [activeStreamController, setActiveStreamController] = useState(null);
  const [uploadedFile, setUploadedFile] = useState(null);
  const [fileId, setFileId] = useState(null);
  const [isUploading, setIsUploading] = useState(false);
  const [fileError, setFileError] = useState(null);
  const [isModelLoading, setIsModelLoading] = useState(false);
  const [loadingModel, setLoadingModel] = useState('');
  const chatContainerRef = useRef(null);

  // Load config.json at runtime using the loadConfig utility
  useEffect(() => {
    const initializeConfig = async () => {
      try {
        const loadedConfig = await loadConfig();
        console.log('Loaded config using loadConfig utility:', loadedConfig);
        setOpenWebUIUrl(loadedConfig.openWebUIUrl || '');
        setApiKey(loadedConfig.apiKey || '');
        setSelectedModel(loadedConfig.selectedModel || '');
      } catch (error) {
        console.error('Error loading config:', error);
        setFetchError('Failed to load configuration. Please check config.json.');
      }
    };

    initializeConfig();
  }, []);

  // This useEffect is no longer needed as we're handling this in the config loading useEffect

  useEffect(() => {
    const initialize = async () => {
      if (openWebUIUrl && apiKey) {
        try {
          const fetchedModels = await fetchModels(openWebUIUrl, apiKey);

          // Store models - handle both object and string formats
          if (Array.isArray(fetchedModels) && fetchedModels.length > 0) {
            setModels(fetchedModels);
            console.log('Fetched models:', fetchedModels);

            // If no model is selected yet, select the first one
            if (!selectedModel) {
              const firstModelId = typeof fetchedModels[0] === 'object' && fetchedModels[0].id
                ? fetchedModels[0].id
                : fetchedModels[0];
              setSelectedModel(firstModelId);
              console.log('Auto-selected first model:', firstModelId);
            }
          } else {
            // If we couldn't load any models, set some defaults
            const defaultModels = [
              "deepseekr138b.deepseek-r1",
              "phi4-mini:latest",
              "phi2:latest",
              "llama2:latest"
            ];
            setModels(defaultModels);
            console.log('Using default models:', defaultModels);
          }
        } catch (error) {
          // If we get an error, set some default models
          const defaultModels = [
            "deepseekr138b.deepseek-r1",
            "phi4-mini:latest",
            "phi2:latest",
            "llama2:latest"
          ];
          setModels(defaultModels);
          console.log('Error fetching models, using defaults:', defaultModels);

          const errorDetails = handleApiError(error, 'Initialization');
          const errorMessage = errorDetails.statusCode === 401 ?
            'Could not load models: Authentication failed. Please check your API key in settings.' :
            `Could not load models: ${errorDetails.message}`;
          setFetchError(errorMessage);
        }
      }
    };

    initialize();
  }, [openWebUIUrl, apiKey]);

  const handleFileUpload = async (file) => {
    console.log('App: handleFileUpload called with file:', file.name, file.type, file.size);
    setUploadedFile(file);
    setIsUploading(true);
    setFileError(null); // Clear any previous errors

    try {
      console.log('App: Uploading file to API...');
      const response = await uploadFile(openWebUIUrl, apiKey, file);
      console.log('App: File uploaded successfully:', response);
      setFileId(response.id);
    } catch (error) {
      const errorDetails = handleApiError(error, 'handleFileUpload');
      const errorMessage = errorDetails.statusCode === 401 ?
        'Authentication failed. Please check your API key in settings.' :
        `Failed to upload file: ${errorDetails.message}`;
      setFileError(errorMessage);
      setUploadedFile(null);
      setFetchError(errorDetails.message);
    } finally {
      console.log('App: Upload process completed');
      setIsUploading(false);
    }
  };

  const handleFileRemove = () => {
    console.log('App: Removing file');
    setUploadedFile(null);
    setFileId(null);
    setFileError(null);
  };

  const handleFileError = (errorMessage) => {
    console.log('App: File error:', errorMessage);
    setFileError(errorMessage);
  };

  const handleSend = async () => {
    if (!input.trim()) return;

    if (input.startsWith('>')) {
      const command = input.substring(1).trim();
      handleCommand(command, setInput, setShowSettings);
      return;
    }

    const userMessage = {
      role: 'user',
      content: input,
      isOriginalUserMessage: true, // Add metadata to identify original user messages
      hasAttachment: !!fileId, // Add flag to indicate if message has a file attachment
      attachmentName: uploadedFile ? uploadedFile.name : null // Add the file name for display
    };
    setMessages(prevMessages => [...prevMessages, userMessage]);
    setInput('');

    // Clear the file immediately after sending
    const tempFileId = fileId; // Store fileId temporarily for the API call
    setUploadedFile(null);
    setFileId(null);

    // Create an initial assistant message ID for tracking
    const assistantMessageId = Date.now();

    // Set typing indicator but don't add the message yet
    setIsTyping(true);

    try {
      // Use streaming API and store the controller
      const controller = await sendChatMessageStreaming(
        openWebUIUrl,
        apiKey,
        selectedModel,
        [...messages, userMessage],
        tempFileId,
        // onChunk callback - add the message if it doesn't exist yet, or update it
        (chunk) => {
          setMessages(prevMessages => {
            const updatedMessages = [...prevMessages];
            const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);

            if (assistantMessageIndex !== -1) {
              // Message exists, update it
              updatedMessages[assistantMessageIndex] = {
                ...updatedMessages[assistantMessageIndex],
                content: updatedMessages[assistantMessageIndex].content + chunk
              };
            } else {
              // Message doesn't exist yet, add it
              updatedMessages.push({
                id: assistantMessageId,
                role: 'assistant',
                content: chunk.trim(),
                isResponseToRetry: false,
                isStreaming: true
              });
            }

            return updatedMessages;
          });
        },
        // onComplete callback - mark streaming as complete
        (fullContent) => {
          setMessages(prevMessages => {
            const updatedMessages = [...prevMessages];
            const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);
            if (assistantMessageIndex !== -1) {
              updatedMessages[assistantMessageIndex] = {
                ...updatedMessages[assistantMessageIndex],
                content: fullContent.trim(),
                isStreaming: false
              };
            }
            return updatedMessages;
          });
          setIsTyping(false);
          setActiveStreamController(null); // Clear the controller when streaming is complete
        }
      );

      // Store the controller so we can abort it if needed
      setActiveStreamController(controller);
    } catch (error) {
      const errorDetails = handleApiError(error, 'handleSendMessage');
      // Check if a message was created and update it, or create a new error message
      setMessages(prevMessages => {
        const updatedMessages = [...prevMessages];
        const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);

        const errorContent = `Error: ${errorDetails.message}${errorDetails.statusCode ? ` (Status: ${errorDetails.statusCode})` : ''}`;

        if (assistantMessageIndex !== -1) {
          // Update existing message with error
          updatedMessages[assistantMessageIndex] = {
            ...updatedMessages[assistantMessageIndex],
            content: errorContent,
            isStreaming: false,
            isError: true
          };
        } else {
          // Create new error message
          updatedMessages.push({
            id: assistantMessageId,
            role: 'assistant',
            content: errorContent,
            isResponseToRetry: false,
            isStreaming: false,
            isError: true
          });
        }

        // Set fetch error state for potential UI display
        setFetchError(errorDetails.message);

        return updatedMessages;
      });
      setIsTyping(false);
      setActiveStreamController(null); // Clear the controller on error
    }
  };

  const handleSettingsChange = (e) => {
    const { name, value } = e.target;
    if (name === 'openWebUIUrl') {
      setOpenWebUIUrl(value);
    } else if (name === 'apiKey') {
      setApiKey(value);
    } else if (name === 'selectedModel') {
      setSelectedModel(value);
    }
  };

  const handleModelChange = (modelId) => {
    // Set loading state
    setIsModelLoading(true);
    setLoadingModel(modelId);

    // Store the model ID in localStorage
    //localStorage.setItem('selectedModel', modelId); // REMOVED
    setSelectedModel(modelId);

    // Simulate loading time (3-5 seconds)
    setTimeout(() => {
      setIsModelLoading(false);
      setLoadingModel('');
    }, 3000 + Math.random() * 2000); // Random time between 3-5 seconds
  };

  const handleSaveSettings = async (e) => {
    e.preventDefault();
    //localStorage.setItem('openWebUIUrl', openWebUIUrl); // REMOVED
    //localStorage.setItem('apiKey', apiKey); // REMOVED
    //localStorage.setItem('selectedModel', selectedModel); // REMOVED
    setShowSettings(false);

    try {
      const fetchedModels = await fetchModels(openWebUIUrl, apiKey);
      // Store full model objects instead of just IDs
      setModels(fetchedModels);
      setFetchError(null);
    } catch (error) {
      const errorDetails = handleApiError(error, 'handleSaveSettings');
      const errorMessage = errorDetails.statusCode === 401 ?
        'Failed to save settings: Authentication failed. Please verify your API key.' :
        `Failed to save settings: ${errorDetails.message}`;
      setFetchError(errorMessage);
    }
  };

  const handleLoadDefaultSettings = () => {
    // Use the dynamically loaded config with fallbacks
    //setOpenWebUIUrl(config.openWebUIUrl || "https://open.sadoway.ca"); // REMOVED
    //setApiKey(config.apiKey || ""); // REMOVED
    //setSelectedModel(config.selectedModel || "phi4-mini:latest"); // REMOVED
    //console.log('Loaded default settings from config:', config); // REMOVED
      setShowSettings(false); // Just close the settings - no loading
  };

  const handleClearChat = () => {
    setMessages([]);
  };

  const handleStopGeneration = (messageId) => {
    console.log('Stopping generation for message:', messageId);

    // If there's an active stream controller, abort it
    if (activeStreamController) {
      activeStreamController.abort();
      setActiveStreamController(null);
    }

    // Update the message to remove streaming state
    setMessages(prevMessages => {
      const updatedMessages = [...prevMessages];

      // Find the streaming message
      let messageIndex = -1;

      if (messageId) {
        // If messageId is provided, find that specific message
        messageIndex = updatedMessages.findIndex(msg => msg.id === messageId);
      } else {
        // Otherwise find any streaming message
        messageIndex = updatedMessages.findIndex(msg => msg.isStreaming);
      }

      if (messageIndex !== -1) {
        updatedMessages[messageIndex] = {
          ...updatedMessages[messageIndex],
          isStreaming: false,
          content: updatedMessages[messageIndex].content + " [Generation stopped]"
        };
      } else {
        // If no streaming message found but we're in typing state,
        // add a new message indicating generation was stopped
        const lastUserMessageIndex = updatedMessages.findLastIndex(msg => msg.role === 'user');
        if (lastUserMessageIndex !== -1) {
          updatedMessages.push({
            id: Date.now(),
            role: 'assistant',
            content: "[Generation stopped before completion]",
            isStreaming: false
          });
        }
      }

      return updatedMessages;
    });

    setIsTyping(false);
  };
  const handleRetrySend = async (retryMessage, originalUserMessageIndex) => {
    setIsTyping(true);
    try {
      // Get message history up to the retry point
      const messageHistory = messages.slice(0, -1); // Remove last assistant message

      // Add our retry prompt with metadata
      const messagesWithRetry = [...messageHistory, {
        role: 'user',
        content: retryMessage,
        isRetryPrompt: true,
        originalUserMessageIndex: originalUserMessageIndex
      }];

      // Log for debugging
      console.log('Sending retry with original message index:', originalUserMessageIndex);

      // Create an initial assistant message ID for tracking
      const assistantMessageId = Date.now();

      // Use streaming API for retry and store the controller
      const controller = await sendChatMessageStreaming(
        openWebUIUrl,
        apiKey,
        selectedModel,
        messagesWithRetry,
        null, // No file ID for retry
        // onChunk callback - add the message if it doesn't exist yet, or update it
        (chunk) => {
          setMessages(prevMessages => {
            const updatedMessages = [...prevMessages];
            const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);

            if (assistantMessageIndex !== -1) {
              // Message exists, update it
              updatedMessages[assistantMessageIndex] = {
                ...updatedMessages[assistantMessageIndex],
                content: updatedMessages[assistantMessageIndex].content + chunk
              };
            } else {
              // Message doesn't exist yet, add it
              updatedMessages.push({
                id: assistantMessageId,
                role: 'assistant',
                content: chunk.trim(),
                isResponseToRetry: true,
                isStreaming: true
              });
            }

            return updatedMessages;
          });
        },
        // onComplete callback - mark streaming as complete
        (fullContent) => {
          setMessages(prevMessages => {
            const updatedMessages = [...prevMessages];
            const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);
            if (assistantMessageIndex !== -1) {
              updatedMessages[assistantMessageIndex] = {
                ...updatedMessages[assistantMessageIndex],
                content: fullContent.trim(),
                isStreaming: false
              };
            }
            return updatedMessages;
          });
          setIsTyping(false);
          setActiveStreamController(null); // Clear the controller when streaming is complete
        }
      );

      // Store the controller so we can abort it if needed
      setActiveStreamController(controller);
    } catch (error) {
      const errorDetails = handleApiError(error, 'handleRetrySend');
      // Check if a message was created and update it, or create a new error message
      setMessages(prevMessages => {
        const updatedMessages = [...prevMessages];
        const assistantMessageIndex = updatedMessages.findIndex(msg => msg.id === assistantMessageId);

        const errorContent = `Error: ${errorDetails.message}${errorDetails.statusCode ? ` (Status: ${errorDetails.statusCode})` : ''}`;

        if (assistantMessageIndex !== -1) {
          // Update existing message with error
          updatedMessages[assistantMessageIndex] = {
            ...updatedMessages[assistantMessageIndex],
            content: errorContent,
            isStreaming: false,
            isError: true
          };
        } else {
          // Create new error message
          updatedMessages.push({
            id: assistantMessageId,
            role: 'assistant',
            content: errorContent,
            isResponseToRetry: true,
            isStreaming: false,
            isError: true
          });
        }

        // Set fetch error state for potential UI display
        setFetchError(errorDetails.message);

        return updatedMessages;
      });
      setIsTyping(false);
      setActiveStreamController(null); // Clear the controller on error
    }
  };

  const handleRetry = (index) => {
    console.log('Retry clicked for message at index:', index);

    // Find the original user message this assistant is responding to
    let originalUserMessageIndex = -1;
    let originalUserMessage = '';

    // Check if the previous message is a retry prompt
    if (index > 0 && messages[index-1].role === 'user' && messages[index-1].isRetryPrompt) {
      // If it's a retry prompt, use its originalUserMessageIndex
      originalUserMessageIndex = messages[index-1].originalUserMessageIndex;
      if (originalUserMessageIndex !== undefined && messages[originalUserMessageIndex]) {
        originalUserMessage = messages[originalUserMessageIndex].content;
        console.log('Found original message via retry prompt metadata:', originalUserMessageIndex);
      }
    }

    // If we couldn't find the original message via metadata, search for it
    if (originalUserMessageIndex === -1 || !originalUserMessage) {
      let userMessageIndex = index - 1;
      while (userMessageIndex >= 0) {
        if (messages[userMessageIndex].role === 'user' && messages[userMessageIndex].isOriginalUserMessage) {
          originalUserMessage = messages[userMessageIndex].content;
          originalUserMessageIndex = userMessageIndex;
          console.log('Found original message by searching:', originalUserMessageIndex);
          break;
        }
        userMessageIndex--;
      }
    }

    // If we still couldn't find an original user message, use the most recent user message
    if (originalUserMessageIndex === -1 || !originalUserMessage) {
      let userMessageIndex = index - 1;
      while (userMessageIndex >= 0) {
        if (messages[userMessageIndex].role === 'user') {
          originalUserMessage = messages[userMessageIndex].content;
          originalUserMessageIndex = userMessageIndex;
          console.log('Falling back to most recent user message:', originalUserMessageIndex);
          break;
        }
        userMessageIndex--;
      }
    }

    if (originalUserMessageIndex >= 0 && originalUserMessage) {
      console.log('Creating retry prompt for original message:', originalUserMessage);

      const retryMessage = `Acknowledge that your previous response wasn't satisfactory and provide a new, different response to the user's question. Take a different approach this time by:
  1. Using a different perspective or methodology
  2. Providing more specific examples or details
  3. Breaking down the explanation in a clearer way
  4. Being more direct and concise
  5. you may get this message again, you need to have a different response each time

  Important: Do not repeat content from your previous response. Focus on giving a fresh, alternative answer that might better address what the user is looking for.

  Original user message: ${originalUserMessage}`;

      handleRetrySend(retryMessage, originalUserMessageIndex);
    } else {
      console.error('Could not find original user message to retry');
    }
  };

  useEffect(() => {
    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;

    const handleResize = () => {
      document.body.style.height = `${window.innerHeight}px`;
    };

    handleResize(); // Set initial height

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [messages]);

  return (
    <div className="container">
      <Header
        handleClearChat={handleClearChat}
        isModelLoading={isModelLoading}
        loadingModel={loadingModel}
      />
      {fetchError && <div className="error-message">{fetchError}</div>}
      <ChatMessages
        messages={messages}
        chatContainerRef={chatContainerRef}
        isTyping={isTyping}
        handleRetry={handleRetry}
        handleStopGeneration={handleStopGeneration}
      />
      {isTyping && (
        <div className="stop-generation-floating">
          <button
            className="stop-button-floating"
            onClick={() => handleStopGeneration()}
            aria-label="Stop generation"
          >
            <FiSquare />
            <span>Stop</span>
          </button>
        </div>
      )}
      <ChatInput
        input={input}
        setInput={setInput}
        handleSend={handleSend}
        models={models}
        selectedModel={selectedModel}
        setSelectedModel={setSelectedModel}
        uploadedFile={uploadedFile}
        onFileUpload={handleFileUpload}
        onFileRemove={handleFileRemove}
        onFileError={handleFileError}
        fileError={fileError}
        isUploading={isUploading}
        onModelChange={handleModelChange}
        isModelLoading={isModelLoading}
      />
      {showSettings && (
        <div className="settings-modal">
          <SettingsModal
            showSettings={showSettings}
            setShowSettings={setShowSettings}
            openWebUIUrl={openWebUIUrl}
            setOpenWebUIUrl={setOpenWebUIUrl}
            apiKey={apiKey}
            setApiKey={setApiKey}
            selectedModel={selectedModel}
            setSelectedModel={setSelectedModel}
            models={models}
            handleSaveSettings={handleSaveSettings}
            handleLoadDefaultSettings={handleLoadDefaultSettings}
          />
        </div>
      )}
    </div>
  );
}

export default App;

================
File: src/commands.js
================
export const handleCommand = (command, setInput, setShowSettings) => {
  switch (command) {
    case 'settings':
      setShowSettings(true);
      break;
    // Add more commands here if needed
    default:
      console.log(`Unknown command: ${command}`);
  }
  setInput(''); // Clear the input field after handling a command
};

================
File: src/components/ChatInput.jsx
================
import React, { useRef, useEffect, useState } from 'react';
import { FiSend, FiChevronDown, FiChevronUp } from 'react-icons/fi';
import FileUpload from './FileUpload';

const ChatInput = ({
  input,
  setInput,
  handleSend,
  selectedModel,
  setSelectedModel,
  models = [],
  uploadedFile,
  onFileUpload,
  onFileRemove,
  onFileError,
  fileError,
  isUploading,
  onModelChange,
  isModelLoading
}) => {
  const textareaRef = useRef(null);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const dropdownRef = useRef(null);

  // Auto-resize the textarea based on content
  useEffect(() => {
    if (textareaRef.current) {
      // Reset height to auto to get the correct scrollHeight
      textareaRef.current.style.height = 'auto';
      
      // Calculate new height (capped at 4 lines)
      const lineHeight = 24; // Approximate line height in pixels
      const maxHeight = lineHeight * 4; // Max height for 4 lines
      const scrollHeight = textareaRef.current.scrollHeight;
      
      // Set the height to either the scrollHeight or maxHeight, whichever is smaller
      textareaRef.current.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
    }
  }, [input]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const handleKeyDown = (e) => {
    // Send message on Enter (without Shift key)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault(); // Prevent default to avoid new line
      handleSend();
    }
  };

  const toggleDropdown = () => {
    setDropdownOpen(!dropdownOpen);
  };

  const selectModel = (model) => {
    if (onModelChange) {
      onModelChange(model);
    } else {
      setSelectedModel(model);
    }
    setDropdownOpen(false);
  };

  return (
    <div className="chat-input-container">
      {fileError && (
        <div className="file-error-message">
          {fileError}
        </div>
      )}
      <div className="input-row">
        <textarea
          ref={textareaRef}
          className="chat-input"
          placeholder={uploadedFile ? `Message with attached file: ${uploadedFile.name}` : "Type your message..."}
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          rows="1"
        />
      </div>
      <div className="input-footer">
        <FileUpload
          onFileUpload={onFileUpload}
          onFileRemove={onFileRemove}
          onError={onFileError}
          uploadedFile={uploadedFile}
          isUploading={isUploading}
        />
        <div className="spacer"></div>
        {models.length > 0 && (
          <div className="custom-dropdown" ref={dropdownRef}>
            <button
              className="dropdown-toggle"
              onClick={toggleDropdown}
              title="Select AI Model"
            >
              <span className="toggle-model-name">
                {selectedModel && (typeof selectedModel === 'object' ? selectedModel.id : selectedModel)}
              </span>
              {dropdownOpen ? <FiChevronUp /> : <FiChevronDown />}
            </button>
            {dropdownOpen && (
              <div className="dropdown-menu">
                {models.map(model => {
                  // Handle both cases: model as object or model as string
                  const modelId = typeof model === 'object' && model.id ? model.id : model;
                  const displayName = typeof model === 'object' && model.name ? model.name : modelId;
                  const selectedModelId = typeof selectedModel === 'object' && selectedModel.id ?
                    selectedModel.id : selectedModel;
                  
                  return (
                    <button
                      key={modelId}
                      className={`dropdown-item ${modelId === selectedModelId ? 'active' : ''}`}
                      onClick={() => selectModel(modelId)}
                    >
                      <div className="model-name">{displayName}</div>
                      {typeof model === 'object' && model.size_parameters && (
                        <div className="model-size">
                          {(model.size_parameters / 1000000000).toFixed(1)}B params
                          {model.quantization_level && ` (${model.quantization_level})`}
                        </div>
                      )}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        )}
        <button className="send-button" onClick={handleSend}>
          <FiSend />
        </button>
      </div>
    </div>
  );
};

export default ChatInput;

================
File: src/components/ChatMessages.jsx
================
import React from 'react';
import { FiCopy, FiRefreshCw, FiSquare } from 'react-icons/fi';
import { getSafeMessageContent } from '../utils/message.jsx';

const ChatMessages = ({ messages, chatContainerRef, isTyping, handleRetry, handleStopGeneration }) => {
  const [showCopyMessage, setShowCopyMessage] = React.useState(false);
  // Add ref for the message container
  const copyMessageRef = React.useRef(null);

  React.useEffect(() => {
    let timeoutId;
    if (showCopyMessage) {
      // Ensure the message is visible by scrolling into view
      if (copyMessageRef.current) {
        copyMessageRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      timeoutId = setTimeout(() => {
        setShowCopyMessage(false);
      }, 1500);
    }
    return () => clearTimeout(timeoutId);
  }, [showCopyMessage]);
  
  // Add event listeners for code block copy buttons
  React.useEffect(() => {
    const handleCodeBlockCopy = (event) => {
      // Check if the click was on a code block's ::after pseudo-element (copy button)
      // We can approximate this by checking if the click is in the top-right corner of a pre element
      if (event.target.tagName === 'PRE') {
        const rect = event.target.getBoundingClientRect();
        const isTopRightCorner =
          event.clientX > rect.right - 50 &&
          event.clientX < rect.right &&
          event.clientY > rect.top &&
          event.clientY < rect.top + 30;
        
        if (isTopRightCorner) {
          // Find the code element inside the pre
          const codeElement = event.target.querySelector('code');
          if (codeElement) {
            // Copy the text content
            navigator.clipboard.writeText(codeElement.textContent)
              .then(() => {
                setShowCopyMessage(true);
                console.log('Code copied to clipboard');
              })
              .catch(err => {
                console.error('Failed to copy code:', err);
              });
          }
        }
      }
    };
    
    // Add the event listener to the chat container
    const chatContainer = chatContainerRef.current;
    if (chatContainer) {
      chatContainer.addEventListener('click', handleCodeBlockCopy);
    }
    
    // Clean up
    return () => {
      if (chatContainer) {
        chatContainer.removeEventListener('click', handleCodeBlockCopy);
      }
    };
  }, [chatContainerRef]);

  const handleCopyMessage = (content) => {
    navigator.clipboard.writeText(content)
      .then(() => {
        setShowCopyMessage(true);
        console.log('Text copied to clipboard:', content);
      })
      .catch(err => {
        console.error('Failed to copy text:', err);
      });
  };
  
  // Function removed: handleCopyMarkdown

  return (
    <>
      {/* Move copy message outside the scrollable container */}
      {showCopyMessage && (
        <div className="copy-message" ref={copyMessageRef}>
          Copied!
        </div>
      )}
      
      <div className="chat-messages" ref={chatContainerRef}>
        {messages.map((message, index) => (
          <div
            key={index}
            className={`message ${message.role === 'user' ? 'user-message' : 'assistant-message'} ${message.hasAttachment ? 'has-attachment' : ''}`}
            data-attachment-name={message.attachmentName || ''}
          >
            <div className={`message-content ${!message.content.includes('\n') ? 'single-line' : ''} ${message.isStreaming ? 'streaming' : ''}`}>
              {getSafeMessageContent(message.content, message.role === 'assistant')}
            </div>
            {message.role === 'assistant' && typeof message.content === 'string' && !message.isStreaming && (
              <div className="message-actions-container">
                <div className="message-actions">
                  <button
                    className="copy-button"
                    onClick={() => handleCopyMessage(message.content)}
                    aria-label="Copy message"
                    title="Copy text"
                  >
                    <FiCopy />
                  </button>
                  <button
                    className="retry-button"
                    onClick={() => handleRetry(index)}
                    aria-label="Retry message"
                    title="Regenerate response"
                  >
                    <FiRefreshCw />
                  </button>
                </div>
              </div>
            )}
          </div>
        ))}
        {isTyping && (
          <div className="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        )}
      </div>
    </>
  );
};

export default ChatMessages;

================
File: src/components/FileUpload.jsx
================
import React, { useRef, useState } from 'react';
import { FiPaperclip, FiX } from 'react-icons/fi';

// Constants
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const ALLOWED_FILE_TYPES = [
  // Document formats
  '.pdf', '.txt', '.doc', '.docx', '.csv', '.rtf', '.md',
  // Image formats
  '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'
];

const FileUpload = ({ onFileUpload, onFileRemove, uploadedFile, isUploading, onError }) => {
  const fileInputRef = useRef(null);
  
  const handleFileSelect = () => {
    console.log('File select button clicked');
    fileInputRef.current.click();
  };

  const handleFileChange = (e) => {
    console.log('File input changed', e.target.files);
    if (e.target.files.length > 0) {
      const file = e.target.files[0];
      console.log('File selected:', file.name, file.type, file.size);
      
      // Check file size
      if (file.size > MAX_FILE_SIZE) {
        console.log('File too large:', file.size);
        onError(`File size exceeds the 10MB limit. Your file is ${(file.size / (1024 * 1024)).toFixed(2)}MB.`);
        return;
      }
      
      // Check file type (by extension)
      const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
      console.log('File extension:', fileExtension);
      if (!ALLOWED_FILE_TYPES.includes(fileExtension)) {
        console.log('File type not supported:', fileExtension);
        onError(`File type not supported. Allowed types: ${ALLOWED_FILE_TYPES.join(', ')}`);
        return;
      }
      
      console.log('File passed validation, uploading...');
      onFileUpload(file);
    }
  };

  // Function to get appropriate icon based on file type
  const getFileIcon = (fileName) => {
    const extension = fileName.split('.').pop().toLowerCase();
    
    // Return appropriate icon based on file type
    switch (extension) {
      case 'pdf':
        return '';
      case 'doc':
      case 'docx':
        return '';
      case 'txt':
      case 'md':
      case 'rtf':
        return '';
      case 'csv':
        return '';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
      case 'webp':
      case 'bmp':
      case 'svg':
        return '';
      default:
        return '';
    }
  };

  return (
    <div className="file-upload-container">
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileChange}
        style={{ display: 'none' }}
        accept={ALLOWED_FILE_TYPES.join(',')}
      />
      
      {!uploadedFile ? (
        <button 
          className="file-upload-button" 
          onClick={handleFileSelect}
          disabled={isUploading}
          title="Attach a file (max 10MB)"
        >
          <FiPaperclip />
        </button>
      ) : (
        <div className="uploaded-file">
          <span className="file-icon">{getFileIcon(uploadedFile.name)}</span>
          <span className="file-name" title={uploadedFile.name}>
            {uploadedFile.name.length > 15 
              ? uploadedFile.name.substring(0, 12) + '...' 
              : uploadedFile.name}
          </span>
          <button 
            className="remove-file-button" 
            onClick={onFileRemove}
            title="Remove file"
          >
            <FiX />
          </button>
        </div>
      )}
      
      {uploadedFile && uploadedFile.type.startsWith('image/') && (
        <div className="image-preview">
          <img 
            src={URL.createObjectURL(uploadedFile)} 
            alt="Preview" 
            className="preview-image"
          />
        </div>
      )}
      
      {isUploading && <span className="upload-spinner"></span>}
    </div>
  );
};

export default FileUpload;

================
File: src/components/Header.jsx
================
import React from 'react';

const Header = ({ handleClearChat, isModelLoading, loadingModel }) => {
  return (
    <div className="chat-header">
      <div className="logo-container">
        <svg className="logo-svg" width="32" height="32" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          {/* Dark background circle */}
          <circle cx="50" cy="50" r="48" fill="#1a1a1a" />
          
          {/* Geometric pattern - inspired by the examples but simplified */}
          <g fill="#ffffff">
            {/* Center circle */}
            <circle cx="50" cy="50" r="8" />
            
            {/* Chunky rays - 8 directions */}
            <rect x="46" y="15" width="8" height="25" />
            <rect x="46" y="60" width="8" height="25" />
            
            <rect x="15" y="46" width="25" height="8" />
            <rect x="60" y="46" width="25" height="8" />
            
            {/* Diagonal rays */}
            <rect x="25" y="25" width="8" height="20" transform="rotate(-45 25 25)" />
            <rect x="75" y="25" width="8" height="20" transform="rotate(45 75 25)" />
            <rect x="25" y="75" width="8" height="20" transform="rotate(-135 25 75)" />
            <rect x="75" y="75" width="8" height="20" transform="rotate(135 75 75)" />
            
            {/* Outer ring segments */}
            <path d="M50 10 A40 40 0 0 1 90 50 L82 50 A32 32 0 0 0 50 18 Z" />
            <path d="M90 50 A40 40 0 0 1 50 90 L50 82 A32 32 0 0 0 82 50 Z" />
            <path d="M50 90 A40 40 0 0 1 10 50 L18 50 A32 32 0 0 0 50 82 Z" />
            <path d="M10 50 A40 40 0 0 1 50 10 L50 18 A32 32 0 0 0 18 50 Z" />
          </g>
        </svg>
        <h2 className="logo-text">chat<span className="logo-dot">.</span>sadoway</h2>
      </div>
      
      {/* Add model loading indicator */}
      {isModelLoading && (
        <div className="model-loading-indicator">
          <div className="loading-spinner"></div>
          <span>Loading {loadingModel}...</span>
        </div>
      )}
      
      <div className="header-buttons">
        <button className="clear-button" onClick={handleClearChat}>
          Clear
        </button>
      </div>
    </div>
  );
};

export default Header;

================
File: src/components/SettingsModal.jsx
================
import React from 'react';

const SettingsModal = ({
  showSettings,
  setShowSettings,
  openWebUIUrl,
  setOpenWebUIUrl,
  apiKey,
  setApiKey,
  selectedModel,
  setSelectedModel,
  models,
  handleSaveSettings,
  handleLoadDefaultSettings,
}) => {
  if (!showSettings) {
    return null;
  }

  return (
    <div className="settings-modal">
      <div className="settings-content"> {/* Added a container for content */}
        <h3>Settings</h3>
        <form className="settings-form" onSubmit={handleSaveSettings}>
          <div className="input-group"> {/* Group URL input */}
            <label htmlFor="openWebUIUrl">API URL:</label>
            <input type="text" id="openWebUIUrl" name="openWebUIUrl" value={openWebUIUrl} onChange={(e) => setOpenWebUIUrl(e.target.value)} />
          </div>

          <div className="input-group"> {/* Group API Key input */}
            <label htmlFor="apiKey">API Key:</label>
            <input type="password" id="apiKey" name="apiKey" value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
          </div>

          <div className="input-group"> {/* Group Model select */}
            <label htmlFor="selectedModel">Model:</label>
            <select id="selectedModel" name="selectedModel" value={selectedModel} onChange={(e) => setSelectedModel(e.target.value)}>
              {models && models.length > 0 ? (
                models.map(model => {
                  // Handle both object and string formats
                  const modelId = typeof model === 'object' && model.id ? model.id : model;
                  const displayName = typeof model === 'object' && model.name ? model.name : modelId;
                  
                  return (
                    <option key={modelId} value={modelId}>
                      {displayName}
                    </option>
                  );
                })
              ) : (
                <option value="">No models available</option>
              )}
            </select>
          </div>

          <div className="button-group"> {/* Group buttons */}
            <button type="button" onClick={handleLoadDefaultSettings}>Load Defaults</button>
            <button type="submit">Save</button>
          </div>
        </form>
        <button className="close-button" onClick={() => setShowSettings(false)}>Close Without Saving</button>
      </div>
    </div>
  );
};

export default SettingsModal;

================
File: src/FILE_MAP.md
================
# Project File Map

This file provides an overview of all the files in the project and their purposes.

## Application Overview

This application is a web-based chat interface for interacting with language models through the OpenWebUI API. It allows users to send messages and receive responses, configure settings, and manage their chat history.

### Key Features

- Chat Interface: Send and receive messages from a language model.
- Command System: Use commands (e.g., ">settings") for specific actions.
- Settings Panel: Configure API keys, URLs, and models.
- Model Selection: Choose different language models.
- Clear Chat History: Erase all messages.
- Error Handling: Display messages for API errors.
- Copy Message: Copy assistant responses.
- Default Settings: Pre-configured settings.

## File Structure

- **`src/App.jsx`:** Main application component, managing state and UI.
- **`src/components/`:**
    - **`ChatInput.jsx`:** Component for user input and sending messages.
    - **`ChatMessages.jsx`:** Displays chat messages.
    - **`Header.jsx`:** Top bar with title and settings button.
    - **`SettingsModal.jsx`:** Modal for configuring settings.
- **`src/api/openwebui.js`:** Functions for interacting with the OpenWebUI API.
- **`src/commands.js`:** Handles command logic.
- **`src/config.json`:** Default configuration settings.
- **`src/index.css`:** Styles for the application.
- **`src/main.jsx`:** Entry point of the application.
- **`src/utils/`:**
    - **`config.js`:** Utility functions for managing configuration.
    - **`error.js`:** Error handling utilities.
    - **`message.jsx`:** Utility functions for handling message content.
- **`vite.config.js`:** Vite configuration file.
- **`package.json`:** Project dependencies and scripts.
- **`package-lock.json`:** Locked dependency versions.
- **`README.md`:** Project information.
- **`.gitignore`:** Files and folders ignored by Git.

================
File: src/index.css
================
/* Base Reset */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: sans-serif;
  background-color: #e8e8e8;
  background-image:
    radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 20%),
    radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 20%),
    radial-gradient(circle at 40% 80%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 30%),
    radial-gradient(circle at 80% 10%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 30%),
    radial-gradient(circle at 10% 90%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 20%),
    radial-gradient(circle at 90% 80%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 20%),
    radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 30%),
    radial-gradient(circle at 60% 40%, rgba(255, 255, 255, 0.01) 0%, rgba(255, 255, 255, 0) 30%);
  color: #333;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: 100vh;
  position: fixed;
  width: 100%;
}

/* Layout */
.container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-height: 100vh;
  overflow: hidden;
  position: relative;
}

/* Header */
.chat-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(180deg, rgba(18, 18, 18, 0.95) 0%, rgba(18, 18, 18, 0.85) 80%, rgba(18, 18, 18, 0) 100%); /* Gradient that fades to transparent */
  padding: 0 clamp(12px, 4vw, 24px); /* Adjusted padding */
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: none; /* Removed border completely */
  z-index: 10; /* Increased z-index to ensure it stays on top */
  height: 60px; /* Fixed height for consistency */
  transition: opacity 0.3s ease;
}

.chat-header:hover {
  opacity: 0.98; /* Subtle hover effect */
}

/* Logo container */
.logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  height: 100%;
}

/* Logo SVG */
.logo-svg {
  width: 32px;
  height: 32px;
  transition: transform 0.3s ease;
}

.logo-container:hover .logo-svg {
  transform: rotate(5deg) scale(1.05);
}

/* Logo text */
.logo-text {
  font-size: clamp(1.1rem, 1.3vw, 1.3rem); /* Slightly larger font */
  font-weight: 600; /* Bolder for business look */
  padding: 0;
  margin: 0;
  color: rgba(229, 229, 229, 0.95); /* Slightly more opaque */
  letter-spacing: 0.03em; /* Increased letter spacing for tech feel */
  display: flex;
  align-items: center;
  height: 100%;
  transition: transform 0.2s ease, opacity 0.2s ease;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); /* Enhanced text shadow */
  font-family: 'Segoe UI', 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif; /* Modern tech font stack */
}

/* Dot styling */
.logo-dot {
  color: #ffffff; /* White to match the SVG */
  font-weight: 700;
  margin: 0 1px;
}

.logo-container:hover .logo-text {
  color: rgba(229, 229, 229, 1); /* Full opacity on hover */
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.25); /* Enhanced shadow on hover */
  transform: translateY(-1px); /* Subtle lift effect */
}

.header-buttons {
  display: flex;
  align-items: center;
  gap: 8px; /* Modern gap property instead of margins */
  height: 100%;
}

.header-buttons button {
  background: rgba(42, 42, 42, 0.3); /* More transparent background */
  border: none; /* Removed border completely */
  color: rgba(229, 229, 229, 0.85); /* Semi-transparent text for better blending */
  font-size: 0.9rem;
  cursor: pointer;
  padding: 6px 12px; /* Slightly reduced padding */
  border-radius: 12px; /* Slightly reduced border radius */
  transition: all 0.2s ease; /* Smooth transition for all properties */
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: none; /* Removed shadow completely */
}

.header-buttons button:hover {
  background-color: rgba(255, 255, 255, 0.1); /* Subtle hover effect */
  color: rgba(229, 229, 229, 1); /* Full opacity on hover */
}

.header-buttons button:active {
  background-color: rgba(255, 255, 255, 0.15); /* Slightly more visible when active */
}

.settings-button svg {
  font-size: 1rem;
  transition: transform 0.2s ease;
}

.settings-button:hover svg {
  transform: rotate(15deg); /* Subtle rotation on hover */
}

/* Mobile adjustments for header */
@media (max-width: 480px) {
  .chat-header {
    padding: 0 12px; /* Reduced padding on small screens */
    height: 50px; /* Slightly smaller height on mobile */
    background: linear-gradient(180deg, rgba(18, 18, 18, 0.92) 0%, rgba(18, 18, 18, 0.8) 80%, rgba(18, 18, 18, 0) 100%); /* Slightly adjusted gradient for mobile */
  }
  
  .header-buttons button {
    padding: 5px 10px; /* Smaller padding on mobile */
    font-size: 0.85rem; /* Smaller font on mobile */
  }
  
  .settings-button svg {
    font-size: 0.9rem; /* Smaller icon on mobile */
  }
  
  /* Mobile logo adjustments */
  .logo-svg {
    width: 28px;
    height: 28px;
  }
  
  .logo-text {
    font-size: 1rem;
  }
  
  .logo-container {
    gap: 8px;
  }
  
  .chat-messages {
    top: 35px; /* Reduced to allow content to flow under the header gradient on mobile */
    padding-top: 15px; /* Slightly reduced padding on mobile */
    padding-bottom: 25px; /* Slightly reduced bottom padding on mobile */
    /* Adjusted fade for mobile - both top and bottom */
    mask-image: linear-gradient(
      to bottom,
      transparent 0%,
      black 15px,
      black calc(100% - 100px),
      transparent 100%
    );
    -webkit-mask-image: linear-gradient(
      to bottom,
      transparent 0%,
      black 15px,
      black calc(100% - 100px),
      transparent 100%
    );
  }
}

.chat-messages {
    top: 40px; /* Reduced to allow content to flow under the header gradient */
    bottom: 25px;
    position: fixed;
    overflow-y: scroll;
    overflow-x: hidden;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 1px);
    max-width: 900px;
    bottom: 6px;
    margin-bottom: 6.5rem; /* Increased from 4.9rem to create more space */
    margin-top: 0; /* Removed margin-top since we're using top value */
    -webkit-overflow-scrolling: touch;
    transition: top 0.3s ease; /* Smooth transition when header height changes */
    padding-top: 20px; /* Add padding to ensure first messages don't appear directly under header */
    padding-bottom: 30px; /* Add padding at the bottom for fade-out effect */
    /* Fade in at top and fade out at bottom */
    mask-image: linear-gradient(
        to bottom,
        transparent 0%,
        black 20px,
        black calc(100% - 120px),
        transparent 100%
    );
    -webkit-mask-image: linear-gradient(
        to bottom,
        transparent 0%,
        black 20px,
        black calc(100% - 120px),
        transparent 100%
    );

    /* Webkit scrollbar styles */
    &::-webkit-scrollbar {
        width: 8px;
    }

    &::-webkit-scrollbar-track {
        background: transparent;
    }

    &::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 4px;
    }

    &::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
    }

    /* Firefox scrollbar styles */
    scrollbar-width: thin;
    scrollbar-color: #d1d5db transparent;
}


.message {
  max-width: 78%;
  clear: both;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  transform: translateY(10px);
  display: block;        /* Changed back to block */
  box-sizing: border-box;
  overflow: hidden; /* Ensure floated children are contained */
  line-height: 1.6; /* Increased for better readability */
}



.user-message {
  margin-left: auto;     /* Push user messages to right */
  width: fit-content;    /* Fit content width */
  min-width: 40%;
  margin-right: 16px;
  padding: 11px 16px 16px 25px;
  align-self: flex-end; /* Ensure it stays on the right */
  margin-top: 8px;
  margin-bottom: 16px;
  font-size: 1.1rem;
  border-radius: 18px 4px 18px 18px; /* Asymmetric corners for character */
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.04),
    0 4px 12px rgba(0, 0, 0, 0.02),
    0 8px 24px rgba(0, 0, 0, 0.01),
    0 0 0 1px rgba(0, 0, 0, 0.02);
  animation: popInuser 0.3s ease forwards;
  background: linear-gradient(135deg, #ffffff, #f8f8f8);
  border-top: 1px solid rgba(255, 255, 255, 0.8); /* Light top border for depth */
  color: rgba(0, 0, 0, 0.85); /* Slightly softer than pure black */
  letter-spacing: 0.01em; /* Subtle letter spacing for better readability */
  transition: box-shadow 0.2s ease, transform 0.2s ease;
  position: relative;
  overflow: hidden;
  float: right; /* Ensure it stays on the right */
  line-height: normal; /* Reset line height */
}

/* Removed blue dot as requested */

.user-message:hover {
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.06),
    0 8px 16px rgba(0, 0, 0, 0.04),
    0 0 0 1px rgba(0, 0, 0, 0.02);
  transform: translateY(-1px); /* Subtle lift effect on hover */
}

@keyframes popInuser {
  from {
    opacity: 0;
    transform: translateY(90px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.assistant-message {
  background-color: #f2f2f2;
  padding: 18px 26px 0px 26px;
  align-self: flex-start;
  color: rgba(0, 0, 0, 0.85); /* Slightly softer than pure black */
  margin-left: 30px;
  margin-top: 5px;
  margin-bottom: 25px; /* Further increased to provide more space for the action buttons */
  font-size: 1.1rem;
  border-radius: 4px 18px 18px 18px; /* Asymmetric corners for character */
  position: relative;
  animation: popInassistant 0.2s ease forwards;
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.06),
    0 4px 12px rgba(0, 0, 0, 0.04),
    0 8px 24px rgba(0, 0, 0, 0.02),
    0 0 0 1px rgba(0, 0, 0, 0.03);
  letter-spacing: 0.01em; /* Subtle letter spacing for better readability */
  border-left: 2px solid rgba(236, 72, 153, 0.2); /* Subtle hint of pink */
  transition: box-shadow 0.2s ease, transform 0.2s ease;
  background-image:
    linear-gradient(to bottom right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
  overflow: hidden;
  float: left; /* Ensure it stays on the left */
  width: fit-content; /* Fit content width */
  line-height: normal; /* Reset line height */
}

.assistant-message::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background:
    radial-gradient(circle at 10% 20%, rgba(236, 72, 153, 0.03), transparent 50%),
    radial-gradient(circle at 80% 80%, rgba(59, 130, 246, 0.03), transparent 50%);
  opacity: 0.5;
  pointer-events: none;
}

.assistant-message:hover {
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.08),
    0 8px 16px rgba(0, 0, 0, 0.06),
    0 0 0 1px rgba(0, 0, 0, 0.03);
  transform: translateY(-1px); /* Subtle lift effect on hover */
}

@keyframes popInassistant {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-content {
  word-wrap: break-word;
  white-space: pre-line;
  margin: 0; /* Remove all margins */
  line-height: 1.6; /* Increased for better readability */
  padding: 0; /* Remove padding to fix spacing */
  text-rendering: optimizeLegibility; /* Better text rendering */
  -webkit-font-smoothing: antialiased; /* Smoother fonts on webkit browsers */
  -moz-osx-font-smoothing: grayscale; /* Smoother fonts on Firefox */
  display: block; /* Change to block */
  height: auto; /* Auto height */
  padding: 15px 26px -50px 26px;
  min-height: 0; /* No minimum height */
}

/* Fix spacing in markdown content */
.markdown-content {
  line-height: 1.6; /* Increased for better readability */
  margin: 0;
  padding: 0;
  display: inline; /* Change to inline */
  width: auto; /* Auto width */
  height: auto; /* Auto height */
  min-height: 0; /* No minimum height */
}

/* Remove ALL margins and padding from all elements */
.markdown-content * {
  margin: 0 !important;
  padding: 0 !important;
  line-height: 1.6 !important; /* Increased for better readability */
}

/* Add spacing only between paragraphs */
.markdown-content p + p {
  margin-top: 0.8em !important; /* Increased for better readability */
}

/* Ensure no bottom margin or padding on any element */
.markdown-content > *:last-child {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
}

/* Special styling for single-line messages */
.single-line {
  padding: 0 !important;
  margin: 0 !important;
  line-height: 1.6 !important; /* Increased for better readability */
  height: auto !important;
  min-height: 0 !important;
}

.single-line .markdown-content,
.single-line .user-content {
  display: inline !important;
  line-height: 1.6 !important; /* Increased for better readability */
}

/* User content styling */
.user-content {
  white-space: pre-line;
  line-height: 1.6; /* Increased for better readability */
  margin: 0;
  padding: 0;
}

/* Adjust padding for messages with single-line content */
.user-message .single-line,
.assistant-message .single-line {
  padding: 0 !important;
  margin: 0 !important;
}

.message-actions-container {
  position: absolute;
  bottom: -35px;  /* Moved down even further from the text */
  left: 10px;  /* Position at the bottom left */
  display: flex;
  flex-direction: row;  /* Changed to row for horizontal layout */
  border-radius: 12px;
  padding: 6px 10px;
  background-color: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(4px);
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.06),
    0 4px 12px rgba(0, 0, 0, 0.04),
    0 8px 24px rgba(0, 0, 0, 0.02),
    0 0 0 1px rgba(0, 0, 0, 0.03);
  z-index: 9000; /* Extremely high z-index to ensure it appears above all other elements */
  border-left: 2px solid rgba(59, 130, 246, 0.2); /* Subtle hint of blue */
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  background-image: linear-gradient(to right, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.95));
  pointer-events: auto !important; /* Ensure clicks are registered */
}

/* Ensure the assistant message doesn't clip the action buttons */
.assistant-message {
  overflow: visible !important;
}

.message-actions-container:hover {
  transform: translateY(-2px);
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.08),
    0 8px 16px rgba(0, 0, 0, 0.06),
    0 0 0 1px rgba(0, 0, 0, 0.03);
}

@media (max-width: 500px) {
  .message-actions-container {
    padding: 4px 6px; /* More compact on mobile */
  }
}

/* Media queries for different screen sizes */
@media (max-width: 1200px) {
  .message-actions-container {
    left: 10px;
  }
}

@media (max-width: 992px) {
  .message-actions-container {
    left: 10px;
  }
}

@media (max-width: 768px) {
  .message-actions-container {
    bottom: -27px; /* Adjusted for medium screens, moved down further */
    left: 10px;
  }
  
  .assistant-message {
    margin-bottom: 50px; /* Significantly increased for better spacing */
  }
}

@media (max-width: 576px) {
  .message-actions-container {
    bottom: -25px; /* Adjusted for small screens, moved down further */
    left: 10px;
  }
  
  .assistant-message {
    margin-bottom: 55px; /* Further increased for small screens */
  }
}

/* For very small screens */
@media (max-width: 375px) {
  .message-actions-container {
    bottom: -22px; /* Further adjusted for very small screens, moved down further */
    left: 8px;
    padding: 3px 5px; /* Even more compact for very small screens */
  }
  
  .assistant-message {
    margin-bottom: 60px; /* Maximum spacing for very small screens */
  }
  
  .copy-button,
  .retry-button {
    width: 24px;
    height: 24px;
    margin: 0 2px;
  }
  
  .message-actions {
    gap: 4px; /* Minimal gap for very small screens */
  }
}

.message-actions {
  display: flex;
  flex-direction: row;  /* Changed to row for horizontal layout */
  gap: 10px;  /* Increased gap for better spacing between buttons */
}

.copy-button,
.retry-button {
  background-color: rgba(255, 255, 255, 0.9);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  padding: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  transition: all 0.2s ease;
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.06),
    0 4px 8px rgba(0, 0, 0, 0.03),
    0 0 0 1px rgba(0, 0, 0, 0.02);
  margin: 0 4px; /* Increased horizontal spacing */
  position: relative;
  overflow: hidden;
}

/* Floating stop generation button */
.stop-generation-floating {
  position: fixed;
  bottom: 90px; /* Position above the chat input */
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  width: auto;
  display: flex;
  justify-content: center;
  animation: fadeInUp 0.3s ease-out;
}

.stop-button-floating {
  background-color: rgba(60, 60, 60, 0.8);
  color: #f0f0f0;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  padding: 6px 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  font-size: 0.9rem;
  font-weight: 500;
  transition: all 0.2s ease;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

.stop-button-floating:hover {
  background-color: rgba(80, 80, 80, 0.9);
  transform: translateY(-1px);
}

.stop-button-floating:active {
  transform: translateY(0);
}

.stop-button-floating svg {
  font-size: 1rem;
  color: #ff9800;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate(-50%, 10px);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

/* Mobile adjustments for stop button */
@media (max-width: 768px) {
  .stop-generation-floating {
    bottom: 100px; /* Position higher on mobile */
  }
  
  .stop-button-floating {
    padding: 6px 14px;
    font-size: 0.9rem;
  }
}

.copy-button {
  background-color: rgba(255, 255, 255, 0.9);
}

.retry-button {
  background-color: rgba(255, 255, 255, 0.9);
  position: relative;
}

.retry-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at top right, rgba(125, 211, 252, 0.15), transparent 70%);
  opacity: 1;
  z-index: -1;
}

.copy-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at top left, rgba(236, 72, 153, 0.15), transparent 70%);
  opacity: 1;
  z-index: -1;
}

.copy-button::after,
.retry-button::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 1;
}

.copy-button:hover,
.retry-button:hover {
  background-color: #ffffff;
  transform: translateY(-2px);
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.08),
    0 8px 16px rgba(0, 0, 0, 0.04),
    0 0 0 1px rgba(0, 0, 0, 0.02);
}

.copy-button:hover::after,
.retry-button:hover::after {
  opacity: 0.6;
}

.copy-button:active,
.retry-button:active {
  transform: translateY(0);
}

.copy-button svg,
.retry-button svg {
  font-size: 0.9rem;
  color: #333;
}

/* Mobile adjustments - moved to smaller breakpoint */
@media (max-width: 500px) {
  .copy-button,
  .retry-button {
    width: 26px;
    height: 26px;
    margin: 0 3px; /* Slightly increased horizontal spacing */
  }
  
  .copy-button svg,
  .retry-button svg {
    font-size: 1rem;
  }
  
  .message-actions {
    gap: 6px; /* Reduced gap for mobile */
  }
}

.typing-indicator {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 16px auto 60px; /* Increased bottom margin to avoid being covered by input */
  animation: slideIn 0.5s ease forwards;
  opacity: 1; /* Make it visible immediately */
  width: 70px;
  height: 24px;
  padding: 0 8px;
  border-radius: 16px;
  background: rgba(42, 42, 42, 0.8);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(4px);
  z-index: 1000; /* Higher z-index to ensure it appears above other elements */
  clear: both; /* Ensure it appears below floated messages */
}

@keyframes slideIn {
  0% {
    opacity: 0.5;
    transform: translateY(10px) scale(0.9);
  }
  50% {
    opacity: 0.8;
    transform: translateY(5px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Dots container */
.typing-indicator::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 20px;
  background: linear-gradient(90deg,
    rgba(255, 255, 255, 0.03) 0%,
    rgba(255, 255, 255, 0.06) 50%,
    rgba(255, 255, 255, 0.03) 100%);
  animation: shimmer 1.5s infinite;
  z-index: 0;
}

@keyframes shimmer {
  0% {
    background-position: -80px 0;
  }
  100% {
    background-position: 80px 0;
  }
}

/* Create three dots */
.typing-indicator span {
  position: relative;
  display: inline-block;
  width: 8px; /* Larger dots */
  height: 8px;
  border-radius: 50%;
  background: #ffffff;
  margin: 0 4px; /* More space between dots */
  transform: translateY(0);
  z-index: 1;
  box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); /* Add glow effect */
}

/* First dot animation */
.typing-indicator span:nth-child(1) {
  animation: bounce 1s infinite 0s;
}

/* Second dot animation */
.typing-indicator span:nth-child(2) {
  animation: bounce 1s infinite 0.15s;
}

/* Third dot animation */
.typing-indicator span:nth-child(3) {
  animation: bounce 1s infinite 0.3s;
}

@keyframes bounce {
  0%, 100% {
    transform: translateY(0) scale(1);
    background: #ffffff;
    opacity: 0.8;
  }
  50% {
    transform: translateY(-7px) scale(1.2); /* More pronounced bounce */
    background: #ff9800;
    opacity: 1;
    box-shadow: 0 0 8px rgba(255, 152, 0, 0.8); /* Stronger glow at peak */
  }
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .typing-indicator {
    margin-bottom: 70px; /* More space on mobile */
    width: 60px; /* Slightly smaller on mobile */
    height: 22px;
  }
  
  .typing-indicator span {
    width: 5px;
    height: 5px;
    margin: 0 2px;
  }
}

/* Small mobile adjustments */
@media (max-width: 480px) {
  .typing-indicator {
    margin-bottom: 80px; /* Even more space on small mobile */
  }
}

/* Very small screens */
@media (max-width: 375px) {
  .typing-indicator {
    margin-bottom: 90px; /* Maximum space on very small screens */
  }
}

/* Chat Input */
.chat-input-container {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 600px;
    background-color: rgba(42, 42, 42, 0.92); /* More transparent for better blending */
    padding: 6px 6px; /* Minimal padding for compact appearance */
    border-radius: 22px; /* More rounded to match send button */
    box-shadow:
        0 1px 4px rgba(0, 0, 0, 0.25),
        0 2px 6px rgba(0, 0, 0, 0.15),
        0 4px 8px rgba(0, 0, 0, 0.08),
        0 -3px 6px rgba(0, 0, 0, 0.12), /* Reduced upward shadow for better fade effect */
        inset 0 1px 1px rgba(255, 255, 255, 0.03);
    z-index: 20; /* Adjusted to be lower than message-actions-container (50) */
    transition: box-shadow 0.3s cubic-bezier(.25,.8,.25,1), height 0.2s ease, opacity 0.3s ease; /* Added opacity transition */
    display: flex;
    flex-direction: column; /* Changed to column to allow for options row at bottom */
    min-height: 34px; /* Further reduced minimum height */
    backdrop-filter: blur(5px); /* Added blur effect for content behind */
    /* Add subtle gradient to top edge to blend with faded messages */
    border: 1px solid rgba(255, 255, 255, 0.03);
    border-top: none;
    /* Gradient overlay to blend with the faded messages */
    &::before {
        content: '';
        position: absolute;
        top: -40px;
        left: 0;
        right: 0;
        height: 40px;
        background: linear-gradient(to bottom, rgba(18, 18, 18, 0), rgba(18, 18, 18, 0.5));
        pointer-events: none;
        z-index: -1;
    }
}

/* Main input area with textarea and send button */
.chat-input-container .input-row {
    display: flex;
    width: 100%;
    align-items: flex-end; /* Changed to flex-end to align items at the bottom */
    position: relative;
    min-height: 34px; /* Further reduced minimum height */
    margin-bottom: 2px; /* Added small bottom margin */
}

/* Input footer with model selector and send button */
.input-footer {
    display: flex;
    align-items: center;
    padding-top: 0px;
    margin: 0 6px 4px; /* Added bottom margin */
    gap: 8px; /* Add gap between elements */
}

/* Spacer to push elements to the sides */
.spacer {
    flex: 1;
}

/* Custom dropdown styling */
.custom-dropdown {
    position: relative;
    display: inline-block;
    margin-right: 4px; /* Add a small margin from the right edge */
    margin-bottom: 4px; /* Add bottom margin */
}

.dropdown-toggle {
    background-color: transparent;
    border: none;
    border-radius: 20px;
    color: #777;
    font-size: 0.8rem;
    padding: 4px 10px 6px; /* Match file upload button padding */
    cursor: pointer;
    outline: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: background-color 0.2s ease;
    min-width: 150px; /* Reduced min-width */
    text-align: center;
    height: 28px;
}

.toggle-model-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 140px;
}

.dropdown-toggle:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.dropdown-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 6px;
    background-color: #2a2a2a;
    border-radius: 20px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    z-index: 110; /* Increased to be higher than send button (101) */
    min-width: 290px;
    max-width: 350px;
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 6px;
}

.dropdown-item {
    display: block;
    width: 100%;
    padding: 12px 16px;
    text-align: left;
    background: none;
    border: none;
    border-radius: 16px;
    color: #dedede;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
    margin-bottom: 4px;
}

.dropdown-item:last-child {
    margin-bottom: 0;
}

.dropdown-item:hover {
    background-color: #3a3a3a;
}

.dropdown-item.active {
    background-color: #3a3a3a;
    font-weight: 500;
}

/* Model info styles */
.model-name {
    font-weight: 600;
    font-size: 1rem;
    color: #fff;
    margin-bottom: 4px;
}

.model-size {
    font-size: 0.8rem;
    color: #aaa;
    opacity: 0.9;
}

.dropdown-item {
    text-align: left;
    padding: 10px 16px;
}

.dropdown-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.dropdown-item.active {
    background-color: rgba(255, 255, 255, 0.15);
}

/* Adjust chat input container padding for the footer */
.chat-input-container {
    padding-bottom: 0px; /* Minimal padding */
}

.chat-input-container:hover {
      box-shadow:
        0 2px 6px rgba(0, 0, 0, 0.35),
        0 4px 8px rgba(0, 0, 0, 0.25),
        0 6px 12px rgba(0, 0, 0, 0.15),
        0 -4px 8px rgba(0, 0, 0, 0.15), /* Reduced upward shadow for better fade effect */
        inset 0 1px 2px rgba(255, 255, 255, 0.1);
      transition: box-shadow 0.3s ease;
}


/* Add media query for small screens */
@media (max-width: 768px) {
    .chat-input-container {
        width: calc(100% - 60px);
        bottom: 25px;
    }
    
    .chat-input {
        padding: 8px 12px;
        max-height: 88px; /* Slightly smaller max height on mobile */
    }
    
    .chat-messages {
        margin-bottom: 7rem; /* Increased spacing on mobile */
    }
    
    .send-button {
        /* No need to override position on mobile, the percentage-based positioning works for all sizes */
    }
}

/* Even more padding for very small screens */
@media (max-width: 480px) {
    .chat-input-container {
        width: calc(100% - 60px);
        bottom: 25px;
        padding: 8px; /* Slightly smaller padding */
    }
    
    .chat-input {
        padding: 6px 10px;
        font-size: clamp(1rem, 2vw, 0.8rem); /* Slightly smaller font */
    }
    
    .chat-messages {
        margin-bottom: 7.5rem; /* Even more spacing on small screens */
    }
}

/* Very small screens */
@media (max-width: 375px) {
    .chat-messages {
        margin-bottom: 8rem; /* Maximum spacing on very small screens */
    }
}

.chat-input-container:focus-within {
    box-shadow:
        0 2px 6px rgba(0, 0, 0, 0.3),
        0 4px 8px rgba(0, 0, 0, 0.2),
        0 6px 12px rgba(0, 0, 0, 0.1),
        0 -4px 8px rgba(0, 0, 0, 0.15), /* Reduced upward shadow */
        inset 0 1px 2px rgba(255, 255, 255, 0.1);
}

.chat-input-container:not(:focus-within) {
    /* Shadow is now handled by the main .chat-input-container style */
}


.chat-input {
    flex-grow: 1;
    width: 100%; /* Full width since send button is now in footer */
    background-color: transparent; /* Changed to transparent to blend with container */
    font-size: clamp(1.2rem, 2.5vw, 0.8rem);
    color: #ccc;
    border: none;
    padding: 8px 10px; /* Minimal padding for compact appearance */
    padding-left: 16px;
    outline: none;
    border-radius: 18px; /* More rounded to match container */
    margin-right: 0; /* No need for margin since send button is now in footer */
    margin-bottom: 4px; /* Added bottom margin */
    min-width: 0;
    resize: none; /* Prevent manual resizing */
    overflow-y: auto; /* Enable scrolling for content that exceeds max height */
    line-height: 1.5; /* Consistent line height */
    max-height: 96px; /* Max height for 4 lines (24px line height  4) */
    min-height: 24px; /* Min height for 1 line */
    display: block; /* Ensure proper display */
    font-family: inherit; /* Match the font of the rest of the app */
    box-shadow: none; /* Removed inner shadow to blend better */
    transition: box-shadow 0.2s ease;
    
    /* Hide scrollbar but keep functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}

.chat-input:focus {
    box-shadow: none; /* No shadow when focused to maintain blended look */
}

/* Hide scrollbar for Chrome, Safari and Opera */
.chat-input::-webkit-scrollbar {
    display: none;
}

.send-button {
  background-color: #ff9800;
  color: white;
  border: none;
  padding: 9px;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
  height: 44px;
  width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  /* margin-bottom: 0px; */
  margin-right: -1px;
  /* margin-left: 0px; */
  z-index: 101;
  box-shadow: 0 1px 2px rgba(31, 41, 55, 0.04),
              0 2px 4px rgba(255, 198, 112, 0.05),
              0 3px 6px rgba(31, 41, 55, 0.04),
              0 4px 8px rgba(255, 145, 77, 0.05);
  border: 1px solid rgba(204, 215, 230, 0.8);
  margin-top: -29px; /* Better alignment with dropdown */
}

.send-button:hover {
  background-color: #e68a00;
}

.send-button svg {
  font-size: 1.2rem;
}

/* Settings Modal */
.settings-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.3s ease;
}

/* Settings Content */
.settings-content {
  background-color: #ffffff;
  border-radius: 20px;
  box-shadow:
    0 10px 30px rgba(0, 0, 0, 0.2),
    0 5px 15px rgba(0, 0, 0, 0.1),
    0 0 1px rgba(0, 0, 0, 0.1);
  color: #333;
  width: calc(100% - 40px);
  max-width: 480px;
  transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  font-size: 0.95rem;
  overflow: hidden;
  animation: modalSlideIn 0.3s cubic-bezier(0.19, 1, 0.22, 1);
  position: relative;
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: translate(-50%, -45%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
}

.settings-content {
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.settings-content h3 {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: #333;
  margin-bottom: 8px;
  letter-spacing: -0.01em;
}

.settings-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.input-group label {
  font-weight: 600;
  font-size: 0.9rem;
  color: #555;
  margin-left: 4px;
  letter-spacing: 0.01em;
}

.input-group input,
.input-group select {
  padding: 12px 16px;
  border-radius: 12px;
  background-color: #f8f8f8;
  color: #333;
  border: 1px solid #e0e0e0;
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.04),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
  transition: all 0.2s ease;
  font-size: 0.95rem;
  font-family: inherit;
}

.input-group input:focus,
.input-group select:focus {
  outline: none;
  border-color: #ff9800;
  background-color: #fff;
  box-shadow:
    0 0 0 3px rgba(255, 152, 0, 0.15),
    inset 0 1px 0 rgba(255, 255, 255, 0.8);
}

.button-group {
  display: flex;
  gap: 12px;
  margin-top: 16px;
}

.button-group button {
  background-color: #ff9800;
  color: white;
  border: none;
  padding: 12px 16px;
  border-radius: 12px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
  flex: 1;
  font-size: 0.95rem;
  box-shadow:
    0 1px 3px rgba(255, 152, 0, 0.3),
    0 1px 2px rgba(0, 0, 0, 0.1);
  letter-spacing: 0.01em;
}

.button-group button:hover {
  transform: translateY(-2px);
  background-color: #f57c00;
  box-shadow:
    0 4px 12px rgba(255, 152, 0, 0.3),
    0 2px 6px rgba(0, 0, 0, 0.1);
}

.button-group button:active {
  transform: translateY(0);
  background-color: #ef6c00;
  box-shadow:
    0 1px 2px rgba(255, 152, 0, 0.3),
    0 1px 1px rgba(0, 0, 0, 0.1);
}

.close-button {
  background-color: #f2f2f2;
  color: #666;
  border: none;
  padding: 12px 16px;
  border-radius: 12px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
  width: 100%;
  font-size: 0.95rem;
  margin-top: 8px;
  box-shadow:
    0 1px 3px rgba(0, 0, 0, 0.1),
    0 1px 2px rgba(0, 0, 0, 0.05);
  letter-spacing: 0.01em;
}

.close-button:hover {
  background-color: #e6e6e6;
  color: #555;
  transform: translateY(-2px);
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.1),
    0 2px 6px rgba(0, 0, 0, 0.05);
}

.close-button:active {
  transform: translateY(0);
  background-color: #ddd;
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.1),
    0 1px 1px rgba(0, 0, 0, 0.05);
}

@media (max-width: 480px) {
  .settings-modal {
    width: calc(100% - 24px);
    max-width: 100%;
  }
  
  .settings-content {
    padding: 20px;
  }
  
  .button-group {
    flex-direction: column;
  }
  
  .button-group button,
  .close-button {
    padding: 14px 16px;
  }
}

/* Error Message */
.error-message {
  color: #ff3b30;
  padding: 10px;
  text-align: center;
}

/* File Upload Styles */
.file-upload-container {
  display: flex;
  align-items: center;
  position: relative;
  margin-right: auto; /* Push to the left side */
  margin-left: 4px; /* Add a small margin from the left edge */
  margin-bottom: 4px; /* Add bottom margin */
}

.file-upload-button {
  background: transparent;
  border: none;
  color: #777;
  cursor: pointer;
  padding: 4px 8px 6px; /* Added bottom padding */
  border-radius: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  height: 28px;
  margin-top: 2px; /* Adjust vertical alignment */
}

.file-upload-button svg {
  font-size: 1.05rem; /* Slightly more subtle icon size */
}

.file-upload-button:hover {
  background-color: rgba(255, 255, 255, 0.05);
  color: #aaa;
}

.uploaded-file {
  display: flex;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: 4px 8px;
  margin-right: 8px;
}

.file-name {
  color: #dedede;
  font-size: 0.85rem;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.file-icon {
  margin-right: 4px;
  font-size: 1rem;
}

.remove-file-button {
  background: transparent;
  border: none;
  color: #999;
  cursor: pointer;
  padding: 4px;
  margin-left: 4px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.remove-file-button:hover {
  color: #ff3b30;
}

.upload-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-top: 2px solid #ffffff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  position: absolute;
  right: -8px;
  top: 50%;
  transform: translateY(-50%);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* File error message styling */
.file-error-message {
  background-color: rgba(255, 59, 48, 0.1);
  color: #ff3b30;
  padding: 8px 12px;
  border-radius: 8px;
  margin-bottom: 8px;
  font-size: 0.9rem;
  text-align: center;
  animation: fadeIn 0.3s ease;
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  margin-bottom: 8px;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Add indicator for messages with attachments */
.user-message.has-attachment {
  position: relative;
  padding-top: 30px; /* Increased padding to make room for the filename */
}

.user-message.has-attachment::before {
  content: '';
  position: absolute;
  top: 8px;
  right: 8px;
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23555' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48'%3E%3C/path%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0.8;
  z-index: 5;
}

/* Add file name display for messages with attachments */
.user-message.has-attachment::after {
  content: attr(data-attachment-name);
  position: absolute;
  top: 8px;
  right: 28px;
  font-size: 0.8rem;
  font-weight: 500;
  color: #555;
  max-width: 200px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  opacity: 1;
  z-index: 5;
  display: block !important; /* Force display */
}

.image-preview {
  position: fixed;
  bottom: 100px; /* Position above the input container */
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 16px;
  background-color: #2a2a2a;
  border-radius: 8px;
  padding: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  z-index: 40; /* Higher z-index to appear above other elements */
}

.preview-image {
  max-width: 150px;
  max-height: 100px;
  border-radius: 4px;
}

/* Footer */
.footer {
  background-color: #eee;
  padding: 10px;
  text-align: center;
  font-size: 0.8rem;
  color: #888;
  box-shadow: 0px -2px 4px rgba(0, 0, 0, 0.25);
}

.copy-message {
  position: fixed;
  bottom: 120px;   /* Moved up a bit to be above the input area */
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 152, 0, 0.95);
  color: white;
  padding: 16px 32px;
  border-radius: 50px;
  font-size: 1.4rem;
  z-index: 9999;  /* Much higher z-index */
  transition: all 0.3s cubic-bezier(.25,.8,.25,1);
  box-shadow: 0 1px 1px rgba(255, 198, 112, 0.08),
              0 2px 2px rgba(255, 198, 112, 0.08),
              0 4px 4px rgba(255, 145, 77, 0.08),
              0 8px 8px rgba(255, 145, 77, 0.08);
  pointer-events: none; /* Let clicks pass through */
}

@media (max-width: 768px) {
  .copy-message {
    width: calc(100% - 40px);
    text-align: center;
  }
}






/* Dark mode styles for user message attachments */
.user-message.has-attachment::before {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23dedede' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48'%3E%3C/path%3E%3C/svg%3E");
}

.user-message.has-attachment::after {
  color: #dedede;
  font-weight: 600;
  display: block !important;
}

/* Dark Theme Overrides */
body {
  background-color: #121212; /* Changed from #000000 to very dark gray */
  background-image:
    radial-gradient(circle at 20% 30%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 20%),
    radial-gradient(circle at 70% 60%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 20%),
    radial-gradient(circle at 40% 80%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 30%),
    radial-gradient(circle at 80% 10%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 30%),
    radial-gradient(circle at 10% 90%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 20%),
    radial-gradient(circle at 90% 80%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 20%),
    radial-gradient(circle at 30% 20%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 30%),
    radial-gradient(circle at 60% 40%, rgba(30, 30, 30, 0.3) 0%, rgba(30, 30, 30, 0) 30%);
  color: #e5e5e5;
}

/* Header styles are now unified for both light and dark themes */
/* The header now uses rgba colors with transparency that work well in both themes */

.user-message {
  background: #2a2a2a;
  color: #f0f0f0;
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.2),
    0 2px 8px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.03);
}

.user-message:hover {
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.25),
    0 4px 12px rgba(0, 0, 0, 0.15);
}

.assistant-message {
  background: #1e1e1e;
  color: #f0f0f0;
  border: 1px solid rgba(255, 255, 255, 0.03);
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.2),
    0 2px 8px rgba(0, 0, 0, 0.1);
  /* margin-bottom is inherited from the main styles */
}

.assistant-message:hover {
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.25),
    0 4px 12px rgba(0, 0, 0, 0.15);
}

.chat-messages::-webkit-scrollbar-thumb {
  background: #111111;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
  background: #1a1a1a;
}

.chat-messages {
  scrollbar-color: #111111 transparent;
}

.message-actions-container {
  background-color: rgba(26, 26, 26, 0.95);
  backdrop-filter: blur(4px);
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.2),
    0 4px 12px rgba(0, 0, 0, 0.15),
    0 8px 24px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(0, 0, 0, 0.3);
  border-left: 2px solid rgba(59, 130, 246, 0.3); /* Subtle hint of blue */
  background-image: linear-gradient(to right, rgba(30, 30, 30, 0.8), rgba(26, 26, 26, 0.95));
  /* No need to override position properties as they're inherited from the main styles */
  /* z-index is inherited from the main styles */
  pointer-events: auto !important; /* Ensure clicks are registered */
}

/* Ensure the assistant message doesn't clip the action buttons in dark mode */
.assistant-message {
  overflow: visible !important;
}

.message-actions-container:hover {
  transform: translateY(-2px);
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.3),
    0 8px 16px rgba(0, 0, 0, 0.2),
    0 0 0 1px rgba(0, 0, 0, 0.3);
}

.copy-button,
.retry-button {
  background-color: rgba(42, 42, 42, 0.9);
  border: none;
  box-shadow:
    0 2px 4px rgba(0, 0, 0, 0.2),
    0 4px 8px rgba(0, 0, 0, 0.1),
    0 0 0 1px rgba(0, 0, 0, 0.3);
}

.copy-button::before {
  background: radial-gradient(circle at top left, rgba(236, 72, 153, 0.2), transparent 70%);
}

.retry-button::before {
  background: radial-gradient(circle at top right, rgba(125, 211, 252, 0.2), transparent 70%);
}

.copy-button::after,
.retry-button::after {
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
}

.copy-button:hover,
.retry-button:hover {
  background-color: #333333;
  transform: translateY(-2px);
  box-shadow:
    0 4px 8px rgba(0, 0, 0, 0.3),
    0 8px 16px rgba(0, 0, 0, 0.2),
    0 0 0 1px rgba(0, 0, 0, 0.3);
}

.copy-button:hover::after,
.retry-button:hover::after {
  opacity: 0.3;
}

.copy-button svg,
.retry-button svg {
  color: #dedede;
}

.typing-indicator::before {
  background: #1a1a1a;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.typing-indicator span {
  background: #ffffff;
}

/* Chat input container styles are now unified for both light and dark themes */
/* The container now uses rgba colors with transparency that work well in both themes */

.chat-input {
  background-color: transparent; /* Changed to transparent to blend with container */
  color: #dedede;
  /* Other properties are inherited from the main styles */
}

.chat-input::placeholder {
  color: #999;
}

/* Dark mode styles for custom dropdown */
.dropdown-toggle {
  background-color: transparent;
  margin: 0;
  color: #777;
  padding: 4px 10px 6px; /* Match file upload button padding */
  text-align: center;
  min-width: 150px; /* Reduced min-width */
}

.dropdown-toggle:hover {
  background-color: rgba(255, 255, 255, 0.05);
  color: #aaa;
}

.dropdown-menu {
  background-color: #2a2a2a;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.dropdown-item {
  color: #dedede;
}

.dropdown-item:hover {
  background-color: #3a3a3a;
}

.dropdown-item.active {
  background-color: #3a3a3a;
}

.send-button {
  background-color: #ffffff;
  color: #000000;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  border: none;
}

.send-button:hover {
  background-color: #e0e0e0;
  box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
}

/* Dark mode settings modal */
.settings-modal {
  background-color: rgba(0, 0, 0, 0.7);
}

/* Dark mode settings content */
.settings-content {
  background-color: #1e1e1e;
  box-shadow:
    0 10px 30px rgba(0, 0, 0, 0.4),
    0 5px 15px rgba(0, 0, 0, 0.3),
    0 0 1px rgba(255, 255, 255, 0.05);
  color: #e0e0e0;
}

.settings-content h3 {
  color: #f0f0f0;
}

.input-group label {
  color: #aaa;
}

.input-group input,
.input-group select {
  background-color: #2a2a2a;
  color: #e0e0e0;
  border: 1px solid #333;
  box-shadow:
    0 1px 2px rgba(0, 0, 0, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.input-group input:focus,
.input-group select:focus {
  border-color: #ff9800;
  background-color: #333;
  box-shadow:
    0 0 0 3px rgba(255, 152, 0, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.button-group button {
  background-color: #ff9800;
  color: #fff;
  box-shadow:
    0 1px 3px rgba(0, 0, 0, 0.3),
    0 1px 2px rgba(0, 0, 0, 0.2);
}

.button-group button:hover {
  background-color: #f57c00;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.3),
    0 2px 6px rgba(0, 0, 0, 0.2);
}

.button-group button:active {
  background-color: #ef6c00;
}

.close-button {
  background-color: #333;
  color: #ccc;
  box-shadow:
    0 1px 3px rgba(0, 0, 0, 0.3),
    0 1px 2px rgba(0, 0, 0, 0.2);
}

.close-button:hover {
  background-color: #444;
  color: #ddd;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.3),
    0 2px 6px rgba(0, 0, 0, 0.2);
}

.close-button:active {
  background-color: #3a3a3a;
}

.copy-message {
  background: rgba(255, 255, 255, 0.9);
  color: #000000;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

/* Markdown Content Styles */
.markdown-content {
  line-height: 1.5; /* Slightly reduced line height */
  color: inherit;
  font-family: inherit;
  padding: 0; /* Remove padding from container */
  margin: 0; /* Remove margin */
  max-width: 100%; /* Full width */
  word-break: break-word; /* Break long words if needed */
  overflow-wrap: break-word; /* Ensure words wrap properly */
}

/* Override default markdown styling to add proper padding */
.assistant-message .markdown-content {
  display: block !important; /* Force block display */
  padding: 0 !important; /* Remove padding from container */
  margin: 0 !important; /* Remove margin */
  width: 100% !important; /* Full width */
}

/* Headings */
.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
  margin-top: 0.4em; /* Further reduced from 0.6em */
  margin-bottom: 0.2em; /* Further reduced from 0.3em */
  font-weight: 600;
  color: inherit;
  line-height: 1.2; /* Reduced from 1.3 */
  border-bottom: none;
}

.markdown-content h1 {
  font-size: 1.4em;
  padding-bottom: 0.2em;
}

.markdown-content h2 {
  font-size: 1.3em;
  padding-bottom: 0.2em;
}

.markdown-content h3 {
  font-size: 1.2em;
}

.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
  font-size: 1.1em;
}

/* Paragraphs and lists */
.markdown-content p {
  margin-bottom: 0.3em; /* Further reduced from 0.5em */
  margin-top: 0.3em; /* Added top margin */
  padding-left: 0.5em; /* Add left padding */
  padding-right: 0.5em; /* Add right padding */
}

.markdown-content ul,
.markdown-content ol {
  margin-left: 2em; /* Increased from 1.2em */
  margin-right: 1em; /* Added right margin */
  margin-bottom: 0.3em; /* Further reduced from 0.5em */
  margin-top: 0.3em; /* Reduced from 0.5em */
  padding-left: 0.5em; /* Add left padding */
  padding-right: 0.5em; /* Add right padding */
}

.markdown-content li {
  margin-bottom: 0.1em; /* Further reduced from 0.2em */
  padding-right: 0.5em; /* Add right padding */
  padding-left: 0.5em; /* Add left padding */
}

/* Ensure lists have proper indentation */
.assistant-message .markdown-content ul,
.assistant-message .markdown-content ol {
  margin-left: 2em !important;
  margin-right: 1em !important;
  padding-left: 0.5em !important;
  padding-right: 0.5em !important;
}

.assistant-message .markdown-content li {
  padding-left: 0.5em !important;
  padding-right: 0.5em !important;
}

.markdown-content li p {
  margin: 0;
}

/* Code blocks and inline code */
.markdown-content code {
  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
  background-color: rgba(0, 0, 0, 0.2);
  color: #ff9800;
  padding: 0.1em 0.3em;
  border-radius: 3px;
  font-size: 0.9em;
  border: 1px solid rgba(255, 255, 255, 0.1);
  margin: 0 2px; /* Add margin to prevent touching edge */
}

.markdown-content pre {
  background-color: rgba(0, 0, 0, 0.2);
  padding: 0.8em; /* Increased padding */
  border-radius: 6px;
  overflow-x: auto;
  margin: 0.5em 0; /* Reduced vertical margin */
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative; /* For positioning the copy button */
  width: calc(100% - 16px) !important; /* Set width with padding in mind */
  max-width: calc(100% - 16px) !important; /* Ensure it doesn't overflow */
}

/* Ensure code blocks have proper padding and don't touch edges */
.assistant-message .markdown-content pre {
  margin-left: 0 !important;
  margin-right: 0 !important;
  width: calc(100% - 16px) !important;
  max-width: calc(100% - 16px) !important;
}

/* Add copy button for code blocks */
.markdown-content pre::after {
  content: "Copy";
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: rgba(42, 42, 42, 0.9);
  color: #ff9800;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid rgba(255, 152, 0, 0.3);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.markdown-content pre:hover::after {
  opacity: 0.8;
}

.markdown-content pre::after:hover {
  opacity: 1;
  background-color: rgba(60, 60, 60, 0.9);
}

.markdown-content pre code {
  background-color: transparent;
  padding: 0;
  border: none;
  color: #e0e0e0;
  font-size: 0.9em;
  line-height: 1.5;
}

/* Blockquotes */
.markdown-content blockquote {
  border-left: 3px solid rgba(255, 152, 0, 0.5);
  padding: 0.3em 1em 0.3em 1em; /* Increased padding all around */
  margin: 0.8em 1em; /* Added horizontal margin */
  color: rgba(255, 255, 255, 0.8);
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 0 4px 4px 0;
  width: calc(100% - 4em) !important; /* Set width with padding and margin in mind */
}

/* Ensure blockquotes have proper padding */
.assistant-message .markdown-content blockquote {
  margin-left: 1em !important;
  margin-right: 1em !important;
  padding: 0.3em 1em 0.3em 1em !important;
}

/* Links */
.markdown-content a {
  color: #ff9800;
  text-decoration: none;
  border-bottom: 1px dotted rgba(255, 152, 0, 0.5);
}

.markdown-content a:hover {
  text-decoration: none;
  border-bottom: 1px solid #ff9800;
}

/* Images */
.markdown-content img {
  max-width: 100%;
  border-radius: 6px;
  margin: 0.8em 0;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Tables */
.markdown-content table {
  border-collapse: collapse;
  width: 100%;
  margin: 0.8em 0;
  font-size: 0.9em;
}

.markdown-content table th,
.markdown-content table td {
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 0.4em 0.6em;
}

.markdown-content table th {
  background-color: rgba(0, 0, 0, 0.2);
  font-weight: 600;
}

.markdown-content table tr {
  background-color: rgba(0, 0, 0, 0.1);
}

.markdown-content table tr:nth-child(2n) {
  background-color: rgba(0, 0, 0, 0.15);
}

/* Horizontal rule */
.markdown-content hr {
  height: 1px;
  border: none;
  background-color: rgba(255, 255, 255, 0.1);
  margin: 1em 0;
}

/* Inline elements */
.markdown-content strong {
  font-weight: 600;
}

.markdown-content em {
  font-style: italic;
}

/* Fix for code blocks in lists */
.markdown-content li pre {
  margin-top: 0.5em;
}

/* Streaming text animation */
.streaming {
  animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0.7; }
  to { opacity: 1; }
}
/* Add a subtle highlight to the last character in streaming text */
.streaming::after {
  content: '';
  display: inline-block;
  width: 2px;
  height: 1em;
  background-color: rgba(255, 152, 0, 0.5);
  margin-left: 1px;
  vertical-align: text-bottom;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.2; }
  50% { opacity: 0.8; }
}

/* Model loading indicator */
.model-loading-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  background-color: rgba(255, 152, 0, 0.15);
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 0.9rem;
  color: #f0f0f0;
  margin-right: 12px;
}

.loading-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid #ff9800;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

================
File: src/main.jsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

================
File: src/utils/config.js
================
/**
 * Configuration utility.
 *
 * This file handles loading and providing access to the default configuration settings.
 *
 * Related files:
 * - src/App.jsx: Uses this utility to initialize default settings.
 * - public/config.json: The file containing the default configuration.
 *
 * For an overview of all project files, see `src/FILE_MAP.md`.
 */

// Cache for the loaded config
let configCache = null;

/**
 * Loads the configuration from the config.json file.
 * Uses a cache-busting query parameter to ensure the latest config is loaded.
 * Throws an error if the config file cannot be loaded.
 */
export const loadConfig = async () => {
  if (configCache) return configCache;

  try {
    // Add cache-busting query parameter
    const response = await fetch('/config.json?t=' + new Date().getTime());
    if (!response.ok) throw new Error('Failed to load config: ' + response.status + ' ' + response.statusText);

    configCache = await response.json();
    console.log('Loaded config from file:', configCache);
    return configCache;
  } catch (error) {
    console.error('Error loading config:', error);
    throw new Error('Failed to load configuration. Please ensure config.json exists and is valid.');
  }
};

================
File: src/utils/error.js
================
export const handleApiError = (error, source) => {
  console.error(`API Error in ${source}:`, error);

  // Extract status code and response text if available
  let statusCode = error.status || (error.response && error.response.status);
  let errorMessage = error.message || 'Unknown error occurred';

  // Handle specific error cases
  if (statusCode === 401) {
    errorMessage = 'Authentication failed. Please check your API key in settings.';
  } else if (statusCode === 403) {
    errorMessage = 'Access denied. Please verify your API key has the correct permissions.';
  } else if (statusCode === 404) {
    errorMessage = 'The requested resource was not found. Please check the API URL in settings.';
  } else if (statusCode >= 500) {
    errorMessage = 'Server error occurred. Please try again later.';
  }

  // If the error message contains a response text, use that instead
  if (error.message && error.message.includes('response text')) {
    try {
      const responseText = error.message.split('response text:')[1].trim();
      const parsedResponse = JSON.parse(responseText);
      if (parsedResponse.error) {
        errorMessage = parsedResponse.error;
      }
    } catch (e) {
      // If we can't parse the response text, stick with the original error message
      console.warn('Could not parse error response:', e);
    }
  }

  return {
    statusCode,
    message: errorMessage,
    originalError: error
  };
};

================
File: src/utils/message.js
================
/**
 * Message utility functions.
 * Provides helper functions for handling message content.
 *
 * For an overview of all project files, see `src/FILE_MAP.md`.
 */

export const getSafeMessageContent = (content) => {
  if (typeof content === 'string') {
    return <span dangerouslySetInnerHTML={{ __html: content }} />;
  } else if (typeof content === 'object') {
    try {
      const stringContent = JSON.stringify(content, null, 2); // Format for readability
      return <pre>{stringContent}</pre>;
    } catch (error) {
      console.error("Error stringifying message content:", error);
      return <span>Error displaying message content.</span>;
    }
  } else if (content) { // Check if content is not null or undefined but not a string or object
    return <span>{String(content)}</span>;
  } else {
    return null; // Or a placeholder like <span>No content</span>
  }
};

================
File: src/utils/message.jsx
================
import React from 'react';
import { marked } from 'marked';

// Configure marked for safe rendering
marked.setOptions({
  breaks: true,  // Convert \n to <br>
  gfm: true,     // GitHub Flavored Markdown
  headerIds: false,
  mangle: false,
  sanitize: false
});

export const getSafeMessageContent = (content, isAssistant = false) => { // Ensure getSafeMessageContent is exported
  if (typeof content === 'string') {
    // Trim whitespace from the beginning and end of the content
    const trimmedContent = content.trim();
    
    // Remove extra blank lines (more than one consecutive newline)
    const normalizedContent = trimmedContent.replace(/\n{3,}/g, '\n\n');
    
    // Only render markdown for assistant messages
    if (isAssistant) {
      // Render markdown and return as HTML
      return <div dangerouslySetInnerHTML={{ __html: marked(normalizedContent) }} className="markdown-content" />;
    } else {
      // For user messages, just return the text without markdown
      return <div className="user-content">{normalizedContent}</div>;
    }
  } else if (typeof content === 'object') {
    try {
      const stringContent = JSON.stringify(content, null, 2);
      // Render as code block only for assistant messages
      if (isAssistant) {
        return <div dangerouslySetInnerHTML={{ __html: marked('```json\n' + stringContent + '\n```') }} className="markdown-content" />;
      } else {
        return <div className="user-content"><pre>{stringContent}</pre></div>;
      }
    } catch (error) {
      console.error("Error stringifying message content:", error);
      return <span>Error displaying message content.</span>;
    }
  } else if (content) {
    return <span>{String(content).trim()}</span>;
  } else {
    return null;
  }
};

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  preview: {
    host: '0.0.0.0',
    port: 4173,
    strictPort: true,
    allowedHosts: ['chat.sadoway.ca']  // Replace with your domain
  },
  server: {
    host: '0.0.0.0',
    port: 4173,
    strictPort: true,
    allowedHosts: ['chat.sadoway.ca']  // Replace with your domain
  },
  build: {
    minify: 'esbuild'
  },
  optimizeDeps: {
    esbuildOptions: {
      target: 'esnext'
    }
  }
})



================================================================
End of Codebase
================================================================
